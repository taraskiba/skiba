{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to skiba","text":"<p>A python package for a foresters to query Google Earth Engine data</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://taraskiba.github.io/skiba</li> </ul> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83c\udf0e Interactive mapping: Create a map with provided coordinates and customizable basemaps and built-in or specified shapefiles</li> <li>\ud83d\udccd Coordinate-point queries: Access and retrieve band values from Google Earth Engine for provided coordinates.</li> <li>\ud83d\udd32 Hidden coordinate queries: Access and retrieve band values from Google Earth Engine for geojson polygons, either provided or buffered through buffer_coordinates function</li> <li>\ud83d\udca1 Got ideas? Send me an email!</li> </ul>"},{"location":"buffer_method/","title":"buffer_method module","text":""},{"location":"buffer_method/#skiba.buffer_method.buffer_method","title":"<code> buffer_method        </code>","text":"Source code in <code>skiba/buffer_method.py</code> <pre><code>class buffer_method:\n    def __init__(self):\n        \"\"\"\n        Initializes the buffer_method class and sets up the GUI components.\n        Part 2 of buffered coordinates approach which accesses GEE datasets and extracts median values.\n        (Part 1 is in buffer_coordinates.py)\n        \"\"\"\n        # File Upload\n        self.file_upload = widgets.FileUpload(\n            accept=\".geojson\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n            multiple=False,  # True to accept multiple files upload else False\n        )\n        # Dropdown\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = buffer_method.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        self.dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n\n        self.start_date = widgets.DatePicker(description=\"Start Date\", disabled=False)\n        self.end_date = widgets.DatePicker(description=\"End Date\", disabled=False)\n\n        self.run_button = widgets.Button(\n            description=\"Run Query\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            icon=\"check\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        self.output = widgets.Output()\n\n        self.run_button.on_click(self.on_button_clicked)\n        self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n        self.hbox = widgets.HBox([self.file_upload, self.dropdown])\n\n        self.hbox_bottom = widgets.HBox(\n            [self.start_date, self.end_date, self.run_button]\n        )\n        self.vbox = widgets.VBox([self.hbox, self.hbox_bottom, self.output])\n\n    def on_dropdown_change(self, change):\n        \"\"\"\n        Callback function to handle dropdown value changes.\"\"\"\n        if change[\"new\"]:\n            with self.output:\n                self.output.clear_output()\n                catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n                data = buffer_method.fetch_geojson(catalog)\n                data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n                change_value = str(change[\"new\"])\n                url = data_dict.get(change_value)\n                print(f\"Selected dataset: {change['new']}\")\n                print(f\"URL: {url}\")\n\n    def on_button_clicked(self, b):\n        \"\"\"\n        Callback function to handle button click events.\n        \"\"\"\n        import io\n\n        with self.output:\n            self.output.clear_output()\n            print(\n                f\"You entered: {self.dropdown.value}. CSV file will be saved to Downloads folder under this name.\"\n            )\n\n            if self.file_upload.value:\n                file_info = self.file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()\n                filename = file_info[\"name\"]\n                print(f\"Filename: {filename}\")\n\n                # --- Modification: Read GeoJSON from bytes ---\n                # Use BytesIO to read the uploaded GeoJSON file\n                geojson_buffer = io.BytesIO(content_bytes)\n                points = gpd.read_file(geojson_buffer)\n            else:\n                print(\"Please upload a GeoJSON file.\")\n                return\n\n            geedata = self.dropdown.value\n            start_date = self.start_date.value\n            end_date = self.end_date.value\n\n            self.extract_median_values(\n                data=points, geedata=geedata, start_date=start_date, end_date=end_date\n            )\n\n    def extract_median_values(self, data, geedata, start_date, end_date, **kwargs):\n        \"\"\"\n        Extracts median values from a GEE dataset for the given geometry.\n\n        Args:\n            data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n            geedata (str): GEE dataset ID.\n            start_date (str): Start date for filtering the dataset.\n            end_date (str): End date for filtering the dataset.\n            **kwargs: Additional arguments for the GEE dataset.\n        \"\"\"\n        if isinstance(data, str):\n            # Assume the file is a GeoJSON or Shapefile with polygons\n            gdf = gpd.read_file(data)\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", inplace=True)\n            else:\n                gdf = gdf.to_crs(\"EPSG:4326\")\n        elif isinstance(data, pd.DataFrame):\n            # If you have a DataFrame, it should already have a 'geometry' column with Polygon objects\n            # If not, you need to construct it-otherwise, just convert to GeoDataFrame\n            gdf = gpd.GeoDataFrame(data, geometry=\"geometry\")\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", inplace=True)\n            else:\n                gdf = gdf.to_crs(\"EPSG:4326\")\n        else:\n            # If already a GeoDataFrame\n            if data.crs is None:\n                gdf = data.set_crs(\"EPSG:4326\")\n            else:\n                gdf = data.to_crs(\"EPSG:4326\")\n\n        geojson = gdf.__geo_interface__\n        fc = gm.geojson_to_ee(geojson)\n\n        # Load the GEE dataset as an image\n        geeimage = buffer_method.load_gee_as_image(geedata, start_date, end_date)\n\n        name = geedata\n        file_name = name.replace(\"/\", \"_\")\n\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        output_file = f\"{file_name}.csv\"\n        out_path = os.path.join(out_dir, output_file)\n\n        # Retrieve data from the image using sampleRegions\n        sampled_data = gm.extract_values_to_points(fc, geeimage, out_path)\n\n        return sampled_data\n\n    def fetch_geojson(url):\n        \"\"\"\n        Fetches GeoJSON data from a given URL.\n\n        Args:\n            url (str): URL to the GeoJSON file.\"\"\"\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raises an exception for HTTP errors\n            geojson_data = response.json()  # Parse the JSON response\n            return geojson_data\n        except requests.exceptions.HTTPError as http_err:\n            print(f\"HTTP error occurred: {http_err}\")\n        except requests.exceptions.ConnectionError as conn_err:\n            print(f\"Error connecting to the server: {conn_err}\")\n        except Exception as err:\n            print(f\"An error occurred: {err}\")\n        return None\n\n    def create_dropdown():\n        \"\"\"\n        Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n        Args:\n            url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n        Returns:\n            ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n        \"\"\"\n\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n\n        data = buffer_method.fetch_geojson(url)\n\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n\n        dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n\n        return dropdown\n\n    def add_date_picker():\n        \"\"\"\n        Creates a date picker widget for selecting dates.\n\n        Returns:\n            ipywidgets.DatePicker: A date picker widget for selecting dates.\"\"\"\n        date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n\n        return date_picker\n\n    def load_gee_as_image(dataset_id, start_date=None, end_date=None, **kwargs):\n        \"\"\"\n        Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n        Optionally filters by start and end date if applicable.\n\n        Parameters:\n            dataset_id (str): The Earth Engine dataset ID.\n            start_date (str): Optional start date in 'YYYY-MM-DD' format.\n            end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n        Returns:\n            ee.Image: The resulting image.\n        \"\"\"\n        # Try loading as Image\n        try:\n            img = ee.Image(dataset_id)\n            # If .getInfo() doesn't throw, it's an Image\n            img.getInfo()\n            return img\n        except Exception:\n            pass\n\n        # Try loading as ImageCollection\n        try:\n            col = ee.ImageCollection(dataset_id)\n            # If date filters are provided, apply them\n            if start_date and end_date:\n                col = col.filterDate(start_date, end_date)\n            else:\n                pass\n            # Reduce to a single image (e.g., median composite)\n            img = col.median()\n            img.getInfo()  # Throws if not valid\n            return img\n        except Exception:\n            pass\n\n        # Try loading as FeatureCollection (convert to raster)\n        try:\n            fc_temp = ee.FeatureCollection(dataset_id)\n            # Convert to raster: burn a value of 1 into a new image\n            img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.constant(1))\n            img.getInfo()\n            return img\n        except Exception:\n            raise ValueError(\n                \"Dataset ID is not a valid Image, ImageCollection, or FeatureCollection.\"\n            )\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initializes the buffer_method class and sets up the GUI components. Part 2 of buffered coordinates approach which accesses GEE datasets and extracts median values. (Part 1 is in buffer_coordinates.py)</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the buffer_method class and sets up the GUI components.\n    Part 2 of buffered coordinates approach which accesses GEE datasets and extracts median values.\n    (Part 1 is in buffer_coordinates.py)\n    \"\"\"\n    # File Upload\n    self.file_upload = widgets.FileUpload(\n        accept=\".geojson\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n        multiple=False,  # True to accept multiple files upload else False\n    )\n    # Dropdown\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    data = buffer_method.fetch_geojson(url)\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n    self.dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n\n    self.start_date = widgets.DatePicker(description=\"Start Date\", disabled=False)\n    self.end_date = widgets.DatePicker(description=\"End Date\", disabled=False)\n\n    self.run_button = widgets.Button(\n        description=\"Run Query\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        icon=\"check\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    self.output = widgets.Output()\n\n    self.run_button.on_click(self.on_button_clicked)\n    self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n    self.hbox = widgets.HBox([self.file_upload, self.dropdown])\n\n    self.hbox_bottom = widgets.HBox(\n        [self.start_date, self.end_date, self.run_button]\n    )\n    self.vbox = widgets.VBox([self.hbox, self.hbox_bottom, self.output])\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.add_date_picker","title":"<code>add_date_picker()</code>","text":"<p>Creates a date picker widget for selecting dates.</p> <p>Returns:</p> Type Description <code>ipywidgets.DatePicker</code> <p>A date picker widget for selecting dates.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def add_date_picker():\n    \"\"\"\n    Creates a date picker widget for selecting dates.\n\n    Returns:\n        ipywidgets.DatePicker: A date picker widget for selecting dates.\"\"\"\n    date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n\n    return date_picker\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.create_dropdown","title":"<code>create_dropdown()</code>","text":"<p>Creates an ipywidgets dropdown menu from a GeoJSON catalog.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the GeoJSON catalog. Defaults to the Opengeos catalog.</p> required <p>Returns:</p> Type Description <code>ipywidgets.Dropdown</code> <p>A dropdown widget with the names from the catalog.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def create_dropdown():\n    \"\"\"\n    Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n    Args:\n        url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n    Returns:\n        ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n    \"\"\"\n\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n\n    data = buffer_method.fetch_geojson(url)\n\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n\n    dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n\n    return dropdown\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.extract_median_values","title":"<code>extract_median_values(self, data, geedata, start_date, end_date, **kwargs)</code>","text":"<p>Extracts median values from a GEE dataset for the given geometry.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, pd.DataFrame, gpd.GeoDataFrame</code> <p>Input data (GeoJSON, DataFrame, or GeoDataFrame).</p> required <code>geedata</code> <code>str</code> <p>GEE dataset ID.</p> required <code>start_date</code> <code>str</code> <p>Start date for filtering the dataset.</p> required <code>end_date</code> <code>str</code> <p>End date for filtering the dataset.</p> required <code>**kwargs</code> <p>Additional arguments for the GEE dataset.</p> <code>{}</code> Source code in <code>skiba/buffer_method.py</code> <pre><code>def extract_median_values(self, data, geedata, start_date, end_date, **kwargs):\n    \"\"\"\n    Extracts median values from a GEE dataset for the given geometry.\n\n    Args:\n        data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n        geedata (str): GEE dataset ID.\n        start_date (str): Start date for filtering the dataset.\n        end_date (str): End date for filtering the dataset.\n        **kwargs: Additional arguments for the GEE dataset.\n    \"\"\"\n    if isinstance(data, str):\n        # Assume the file is a GeoJSON or Shapefile with polygons\n        gdf = gpd.read_file(data)\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", inplace=True)\n        else:\n            gdf = gdf.to_crs(\"EPSG:4326\")\n    elif isinstance(data, pd.DataFrame):\n        # If you have a DataFrame, it should already have a 'geometry' column with Polygon objects\n        # If not, you need to construct it-otherwise, just convert to GeoDataFrame\n        gdf = gpd.GeoDataFrame(data, geometry=\"geometry\")\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", inplace=True)\n        else:\n            gdf = gdf.to_crs(\"EPSG:4326\")\n    else:\n        # If already a GeoDataFrame\n        if data.crs is None:\n            gdf = data.set_crs(\"EPSG:4326\")\n        else:\n            gdf = data.to_crs(\"EPSG:4326\")\n\n    geojson = gdf.__geo_interface__\n    fc = gm.geojson_to_ee(geojson)\n\n    # Load the GEE dataset as an image\n    geeimage = buffer_method.load_gee_as_image(geedata, start_date, end_date)\n\n    name = geedata\n    file_name = name.replace(\"/\", \"_\")\n\n    out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n    output_file = f\"{file_name}.csv\"\n    out_path = os.path.join(out_dir, output_file)\n\n    # Retrieve data from the image using sampleRegions\n    sampled_data = gm.extract_values_to_points(fc, geeimage, out_path)\n\n    return sampled_data\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.fetch_geojson","title":"<code>fetch_geojson(url)</code>","text":"<p>Fetches GeoJSON data from a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the GeoJSON file.</p> required Source code in <code>skiba/buffer_method.py</code> <pre><code>def fetch_geojson(url):\n    \"\"\"\n    Fetches GeoJSON data from a given URL.\n\n    Args:\n        url (str): URL to the GeoJSON file.\"\"\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # Raises an exception for HTTP errors\n        geojson_data = response.json()  # Parse the JSON response\n        return geojson_data\n    except requests.exceptions.HTTPError as http_err:\n        print(f\"HTTP error occurred: {http_err}\")\n    except requests.exceptions.ConnectionError as conn_err:\n        print(f\"Error connecting to the server: {conn_err}\")\n    except Exception as err:\n        print(f\"An error occurred: {err}\")\n    return None\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.load_gee_as_image","title":"<code>load_gee_as_image(dataset_id, start_date=None, end_date=None, **kwargs)</code>","text":"<p>Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image. Optionally filters by start and end date if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The Earth Engine dataset ID.</p> required <code>start_date</code> <code>str</code> <p>Optional start date in 'YYYY-MM-DD' format.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>Optional end date in 'YYYY-MM-DD' format.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The resulting image.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def load_gee_as_image(dataset_id, start_date=None, end_date=None, **kwargs):\n    \"\"\"\n    Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n    Optionally filters by start and end date if applicable.\n\n    Parameters:\n        dataset_id (str): The Earth Engine dataset ID.\n        start_date (str): Optional start date in 'YYYY-MM-DD' format.\n        end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        ee.Image: The resulting image.\n    \"\"\"\n    # Try loading as Image\n    try:\n        img = ee.Image(dataset_id)\n        # If .getInfo() doesn't throw, it's an Image\n        img.getInfo()\n        return img\n    except Exception:\n        pass\n\n    # Try loading as ImageCollection\n    try:\n        col = ee.ImageCollection(dataset_id)\n        # If date filters are provided, apply them\n        if start_date and end_date:\n            col = col.filterDate(start_date, end_date)\n        else:\n            pass\n        # Reduce to a single image (e.g., median composite)\n        img = col.median()\n        img.getInfo()  # Throws if not valid\n        return img\n    except Exception:\n        pass\n\n    # Try loading as FeatureCollection (convert to raster)\n    try:\n        fc_temp = ee.FeatureCollection(dataset_id)\n        # Convert to raster: burn a value of 1 into a new image\n        img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.constant(1))\n        img.getInfo()\n        return img\n    except Exception:\n        raise ValueError(\n            \"Dataset ID is not a valid Image, ImageCollection, or FeatureCollection.\"\n        )\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.on_button_clicked","title":"<code>on_button_clicked(self, b)</code>","text":"<p>Callback function to handle button click events.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def on_button_clicked(self, b):\n    \"\"\"\n    Callback function to handle button click events.\n    \"\"\"\n    import io\n\n    with self.output:\n        self.output.clear_output()\n        print(\n            f\"You entered: {self.dropdown.value}. CSV file will be saved to Downloads folder under this name.\"\n        )\n\n        if self.file_upload.value:\n            file_info = self.file_upload.value[0]\n            content_bytes = file_info[\"content\"].tobytes()\n            filename = file_info[\"name\"]\n            print(f\"Filename: {filename}\")\n\n            # --- Modification: Read GeoJSON from bytes ---\n            # Use BytesIO to read the uploaded GeoJSON file\n            geojson_buffer = io.BytesIO(content_bytes)\n            points = gpd.read_file(geojson_buffer)\n        else:\n            print(\"Please upload a GeoJSON file.\")\n            return\n\n        geedata = self.dropdown.value\n        start_date = self.start_date.value\n        end_date = self.end_date.value\n\n        self.extract_median_values(\n            data=points, geedata=geedata, start_date=start_date, end_date=end_date\n        )\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.on_dropdown_change","title":"<code>on_dropdown_change(self, change)</code>","text":"<p>Callback function to handle dropdown value changes.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def on_dropdown_change(self, change):\n    \"\"\"\n    Callback function to handle dropdown value changes.\"\"\"\n    if change[\"new\"]:\n        with self.output:\n            self.output.clear_output()\n            catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n            data = buffer_method.fetch_geojson(catalog)\n            data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n            change_value = str(change[\"new\"])\n            url = data_dict.get(change_value)\n            print(f\"Selected dataset: {change['new']}\")\n            print(f\"URL: {url}\")\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#skiba.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>skiba/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/taraskiba/skiba/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>skiba could always use more documentation, whether as part of the official skiba docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/taraskiba/skiba/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up skiba for local development.</p> <ol> <li> <p>Fork the skiba repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/skiba.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv skiba\n$ cd skiba/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 skiba tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/taraskiba/skiba/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"data_process/","title":"data_process module","text":""},{"location":"data_process/#skiba.data_process.data_process","title":"<code> data_process        </code>","text":"Source code in <code>skiba/data_process.py</code> <pre><code>class data_process:\n    def __init__(self):\n        # File Upload\n        self.file_upload = widgets.FileUpload(\n            accept=\".csv, .txt\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n            multiple=False,  # True to accept multiple files upload else False\n        )\n        # Dropdown\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = data_process.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        self.dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n\n        self.start_date = widgets.DatePicker(description=\"Start Date\", disabled=False)\n        self.end_date = widgets.DatePicker(description=\"End Date\", disabled=False)\n\n        self.run_button = widgets.Button(\n            description=\"Run Query\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            icon=\"rotate right\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        self.output = widgets.Output()\n\n        self.run_button.on_click(self.on_button_clicked)\n        self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n        self.hbox = widgets.HBox(\n            [\n                self.file_upload,\n                self.dropdown,\n                self.start_date,\n                self.end_date,\n                self.run_button,\n            ]\n        )\n        self.vbox = widgets.VBox([self.hbox, self.output])\n\n    def on_dropdown_change(self, change):\n        if change[\"new\"]:\n            with self.output:\n                self.output.clear_output()\n                catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n                data = data_process.fetch_geojson(catalog)\n                data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n                change_value = str(change[\"new\"])\n                url = data_dict.get(change_value)\n                print(f\"Selected dataset: {change['new']}\")\n                print(f\"URL: {url}\")\n\n    def on_button_clicked(self, b):\n        with self.output:\n            self.output.clear_output()\n            print(\n                f\"You entered: {self.dropdown.value}. CSV file will be saved to Downloads folder under this name.\"\n            )\n\n            import io\n\n            if self.file_upload.value:\n                # For the first file (if multiple=False)\n                file_info = self.file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()  # file content as bytes\n                filename = file_info[\"name\"]\n                print(f\"Filename: {filename}\")\n                points = pd.read_csv(io.BytesIO(content_bytes))\n            else:\n                print(\"Please upload a CSV file.\")\n\n            geedata = self.dropdown.value\n            start_date = self.start_date.value\n            end_date = self.end_date.value\n\n            self.get_coordinate_data(\n                data=points, geedata=geedata, start_date=start_date, end_date=end_date\n            )\n\n    def get_coordinate_data(self, data, geedata, start_date, end_date, **kwargs):\n        \"\"\"\n        Pull data from provided coordinates from GEE.\n\n        Args:\n            data (str): The data to get the coordinate data from.\n\n        Returns:\n            data (str): CSV file contained GEE data.\n        \"\"\"\n\n        # Load data with safety checks\n        if isinstance(data, str):\n            coordinates = pd.read_csv(data)\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        elif isinstance(data, pd.DataFrame):\n            coordinates = data\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        else:\n            gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n        geojson = gdf.__geo_interface__\n        fc = gm.geojson_to_ee(geojson)\n\n        # Load the GEE dataset as an image\n        geeimage = data_process.load_gee_as_image(geedata, start_date, end_date)\n\n        name = geedata\n        file_name = name.replace(\"/\", \"_\")\n\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        output_file = f\"{file_name}.csv\"\n        out_path = os.path.join(out_dir, output_file)\n\n        # Retrieve data from the image using sampleRegions\n        sampled_data = gm.extract_values_to_points(fc, geeimage, out_path)\n\n        return sampled_data\n\n    def fetch_geojson(url):\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raises an exception for HTTP errors\n            geojson_data = response.json()  # Parse the JSON response\n            return geojson_data\n        except requests.exceptions.HTTPError as http_err:\n            print(f\"HTTP error occurred: {http_err}\")\n        except requests.exceptions.ConnectionError as conn_err:\n            print(f\"Error connecting to the server: {conn_err}\")\n        except Exception as err:\n            print(f\"An error occurred: {err}\")\n        return None\n\n    def create_dropdown():\n        \"\"\"\n        Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n        Args:\n            url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n        Returns:\n            ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n        \"\"\"\n\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n\n        data = data_process.fetch_geojson(url)\n\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n\n        dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n\n        return dropdown\n\n    def add_date_picker():\n        date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n\n        return date_picker\n\n    def load_gee_as_image(dataset_id, start_date=None, end_date=None, **kwargs):\n        \"\"\"\n        Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n        Optionally filters by start and end date if applicable.\n\n        Parameters:\n            dataset_id (str): The Earth Engine dataset ID.\n            start_date (str): Optional start date in 'YYYY-MM-DD' format.\n            end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n        Returns:\n            ee.Image: The resulting image.\n        \"\"\"\n        # Try loading as Image\n        try:\n            img = ee.Image(dataset_id)\n            # If .getInfo() doesn't throw, it's an Image\n            img.getInfo()\n            return img\n        except Exception:\n            pass\n\n        # Try loading as ImageCollection\n        try:\n            col = ee.ImageCollection(dataset_id)\n            # If date filters are provided, apply them\n            if start_date and end_date:\n                col = col.filterDate(start_date, end_date)\n            else:\n                pass\n            # Reduce to a single image (e.g., median composite)\n            img = col.median()\n            img.getInfo()  # Throws if not valid\n            return img\n        except Exception:\n            pass\n\n        # Try loading as FeatureCollection (convert to raster)\n        try:\n            fc_temp = ee.FeatureCollection(dataset_id)\n            # Convert to raster: burn a value of 1 into a new image\n            img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.constant(1))\n            img.getInfo()\n            return img\n        except Exception:\n            raise ValueError(\n                \"Dataset ID is not a valid Image, ImageCollection, or FeatureCollection.\"\n            )\n</code></pre>"},{"location":"data_process/#skiba.data_process.data_process.create_dropdown","title":"<code>create_dropdown()</code>","text":"<p>Creates an ipywidgets dropdown menu from a GeoJSON catalog.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the GeoJSON catalog. Defaults to the Opengeos catalog.</p> required <p>Returns:</p> Type Description <code>ipywidgets.Dropdown</code> <p>A dropdown widget with the names from the catalog.</p> Source code in <code>skiba/data_process.py</code> <pre><code>def create_dropdown():\n    \"\"\"\n    Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n    Args:\n        url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n    Returns:\n        ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n    \"\"\"\n\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n\n    data = data_process.fetch_geojson(url)\n\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n\n    dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n\n    return dropdown\n</code></pre>"},{"location":"data_process/#skiba.data_process.data_process.get_coordinate_data","title":"<code>get_coordinate_data(self, data, geedata, start_date, end_date, **kwargs)</code>","text":"<p>Pull data from provided coordinates from GEE.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to get the coordinate data from.</p> required <p>Returns:</p> Type Description <code>data (str)</code> <p>CSV file contained GEE data.</p> Source code in <code>skiba/data_process.py</code> <pre><code>def get_coordinate_data(self, data, geedata, start_date, end_date, **kwargs):\n    \"\"\"\n    Pull data from provided coordinates from GEE.\n\n    Args:\n        data (str): The data to get the coordinate data from.\n\n    Returns:\n        data (str): CSV file contained GEE data.\n    \"\"\"\n\n    # Load data with safety checks\n    if isinstance(data, str):\n        coordinates = pd.read_csv(data)\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    elif isinstance(data, pd.DataFrame):\n        coordinates = data\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    else:\n        gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n    geojson = gdf.__geo_interface__\n    fc = gm.geojson_to_ee(geojson)\n\n    # Load the GEE dataset as an image\n    geeimage = data_process.load_gee_as_image(geedata, start_date, end_date)\n\n    name = geedata\n    file_name = name.replace(\"/\", \"_\")\n\n    out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n    output_file = f\"{file_name}.csv\"\n    out_path = os.path.join(out_dir, output_file)\n\n    # Retrieve data from the image using sampleRegions\n    sampled_data = gm.extract_values_to_points(fc, geeimage, out_path)\n\n    return sampled_data\n</code></pre>"},{"location":"data_process/#skiba.data_process.data_process.load_gee_as_image","title":"<code>load_gee_as_image(dataset_id, start_date=None, end_date=None, **kwargs)</code>","text":"<p>Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image. Optionally filters by start and end date if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The Earth Engine dataset ID.</p> required <code>start_date</code> <code>str</code> <p>Optional start date in 'YYYY-MM-DD' format.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>Optional end date in 'YYYY-MM-DD' format.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The resulting image.</p> Source code in <code>skiba/data_process.py</code> <pre><code>def load_gee_as_image(dataset_id, start_date=None, end_date=None, **kwargs):\n    \"\"\"\n    Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n    Optionally filters by start and end date if applicable.\n\n    Parameters:\n        dataset_id (str): The Earth Engine dataset ID.\n        start_date (str): Optional start date in 'YYYY-MM-DD' format.\n        end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        ee.Image: The resulting image.\n    \"\"\"\n    # Try loading as Image\n    try:\n        img = ee.Image(dataset_id)\n        # If .getInfo() doesn't throw, it's an Image\n        img.getInfo()\n        return img\n    except Exception:\n        pass\n\n    # Try loading as ImageCollection\n    try:\n        col = ee.ImageCollection(dataset_id)\n        # If date filters are provided, apply them\n        if start_date and end_date:\n            col = col.filterDate(start_date, end_date)\n        else:\n            pass\n        # Reduce to a single image (e.g., median composite)\n        img = col.median()\n        img.getInfo()  # Throws if not valid\n        return img\n    except Exception:\n        pass\n\n    # Try loading as FeatureCollection (convert to raster)\n    try:\n        fc_temp = ee.FeatureCollection(dataset_id)\n        # Convert to raster: burn a value of 1 into a new image\n        img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.constant(1))\n        img.getInfo()\n        return img\n    except Exception:\n        raise ValueError(\n            \"Dataset ID is not a valid Image, ImageCollection, or FeatureCollection.\"\n        )\n</code></pre>"},{"location":"faq/","title":"FAQ","text":"<p>I don't get asked many questions shrug</p>"},{"location":"foliumcode/","title":"folium code","text":""},{"location":"foliumcode/#skiba.foliumcode.Map","title":"<code> Map            (Map)         </code>","text":"<p>A custom Map class that extends folium.Map.</p> Source code in <code>skiba/foliumcode.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"A custom Map class that extends folium.Map.\"\"\"\n\n    def __init__(self, center=(0, 0), zoom=2, **kwargs):\n        \"\"\"Initializes the Map object.\n\n        Args:\n            center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n            zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n            **kwargs: Additional keyword arguments for the folium.Map class.\n        \"\"\"\n        super().__init__(location=center, zoom_start=zoom, **kwargs)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson = folium.GeoJson(data=geojson, **kwargs)\n        geojson.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n        \"\"\"Add a split map to the folium map. Can handle TIF files.\n\n        Args:\n            left (str, optional): basemap for left side. Defaults to \"openstreetmap\".\n            right (str, optional): basemap for right side. Defaults to \"cartodbpositron\".\n        \"\"\"\n\n        from localtileserver import TileClient, get_folium_tile_layer\n\n        # map_types = {\n        #     \"ROADMAP\": \"m\",\n        #     \"SATELLITE\": \"s\",\n        #     \"HYBRID\": \"y\",\n        #     \"TERRAIN\": \"p\",\n        # }\n\n        # map_type = map_types[map_type.upper()]\n\n        # url = (\n        #     f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        # )\n        def _create_layer(source, **kwargs):\n            if str(source).lower().endswith((\".tif\", \".tiff\")):\n                # Create a TileClient for the raster file\n                tile_client = TileClient(source)\n                # Generate a Folium tile layer from the TileClient\n                return get_folium_tile_layer(tile_client, **kwargs)\n            else:\n                # Create a standard Folium TileLayer for basemaps\n                return folium.TileLayer(source, **kwargs)\n\n        layer_right = _create_layer(right, **kwargs)\n        layer_left = _create_layer(left, **kwargs)\n\n        sbs = folium.plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n        sbs.add_to(self)\n\n    def change_basemap(self, **kwargs):\n        \"\"\"Changes the basemap of the map.\n\n        Args:\n            **kwargs: Additional keyword arguments for the folium.TileLayer class.\n        \"\"\"\n        from ipywidgets import jslink, Dropdown\n        from ipyleaflet import WidgetControl\n\n        # Step 4: Create the dropdown\n        data_dict = {\n            \"OpenStreetMap\": \"openstreetmap\",\n            \"CartoDB Positron\": \"cartodbpositron\",\n            \"Stamen Terrain\": \"stamenterrain\",\n            \"Stamen Toner\": \"stamentoner\",\n            \"Stamen Watercolor\": \"stamenwatercolor\",\n        }\n        dropdown = Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n\n        basemap_layer = self.layers[1]\n        jslink((dropdown, \"value\"), (basemap_layer, \"basemap\"))\n        dropdown = WidgetControl(widget=dropdown, position=\"topright\")\n\n        self.add(dropdown)\n\n    def on_dropdown_change(change):\n        if change[\"new\"]:\n            m.add_basemap(change[\"new\"])\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.__init__","title":"<code>__init__(self, center=(0, 0), zoom=2, **kwargs)</code>  <code>special</code>","text":"<p>Initializes the Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>The initial center of the map as (latitude, longitude). Defaults to (0, 0).</p> <code>(0, 0)</code> <code>zoom</code> <code>int</code> <p>The initial zoom level of the map. Defaults to 2.</p> <code>2</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.Map class.</p> <code>{}</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def __init__(self, center=(0, 0), zoom=2, **kwargs):\n    \"\"\"Initializes the Map object.\n\n    Args:\n        center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n        zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n        **kwargs: Additional keyword arguments for the folium.Map class.\n    \"\"\"\n    super().__init__(location=center, zoom_start=zoom, **kwargs)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.GeoJson layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson = folium.GeoJson(data=geojson, **kwargs)\n    geojson.add_to(self)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_split_map","title":"<code>add_split_map(self, left='openstreetmap', right='cartodbpositron', **kwargs)</code>","text":"<p>Add a split map to the folium map. Can handle TIF files.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>basemap for left side. Defaults to \"openstreetmap\".</p> <code>'openstreetmap'</code> <code>right</code> <code>str</code> <p>basemap for right side. Defaults to \"cartodbpositron\".</p> <code>'cartodbpositron'</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n    \"\"\"Add a split map to the folium map. Can handle TIF files.\n\n    Args:\n        left (str, optional): basemap for left side. Defaults to \"openstreetmap\".\n        right (str, optional): basemap for right side. Defaults to \"cartodbpositron\".\n    \"\"\"\n\n    from localtileserver import TileClient, get_folium_tile_layer\n\n    # map_types = {\n    #     \"ROADMAP\": \"m\",\n    #     \"SATELLITE\": \"s\",\n    #     \"HYBRID\": \"y\",\n    #     \"TERRAIN\": \"p\",\n    # }\n\n    # map_type = map_types[map_type.upper()]\n\n    # url = (\n    #     f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    # )\n    def _create_layer(source, **kwargs):\n        if str(source).lower().endswith((\".tif\", \".tiff\")):\n            # Create a TileClient for the raster file\n            tile_client = TileClient(source)\n            # Generate a Folium tile layer from the TileClient\n            return get_folium_tile_layer(tile_client, **kwargs)\n        else:\n            # Create a standard Folium TileLayer for basemaps\n            return folium.TileLayer(source, **kwargs)\n\n    layer_right = _create_layer(right, **kwargs)\n    layer_left = _create_layer(left, **kwargs)\n\n    sbs = folium.plugins.SideBySideLayers(\n        layer_left=layer_left, layer_right=layer_right\n    )\n\n    layer_left.add_to(self)\n    layer_right.add_to(self)\n    sbs.add_to(self)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.change_basemap","title":"<code>change_basemap(self, **kwargs)</code>","text":"<p>Changes the basemap of the map.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments for the folium.TileLayer class.</p> <code>{}</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def change_basemap(self, **kwargs):\n    \"\"\"Changes the basemap of the map.\n\n    Args:\n        **kwargs: Additional keyword arguments for the folium.TileLayer class.\n    \"\"\"\n    from ipywidgets import jslink, Dropdown\n    from ipyleaflet import WidgetControl\n\n    # Step 4: Create the dropdown\n    data_dict = {\n        \"OpenStreetMap\": \"openstreetmap\",\n        \"CartoDB Positron\": \"cartodbpositron\",\n        \"Stamen Terrain\": \"stamenterrain\",\n        \"Stamen Toner\": \"stamentoner\",\n        \"Stamen Watercolor\": \"stamenwatercolor\",\n    }\n    dropdown = Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n\n    basemap_layer = self.layers[1]\n    jslink((dropdown, \"value\"), (basemap_layer, \"basemap\"))\n    dropdown = WidgetControl(widget=dropdown, position=\"topright\")\n\n    self.add(dropdown)\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install skiba, run this command in your terminal:</p> <pre><code>pip install skiba\n</code></pre> <p>This is the preferred method to install skiba, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install skiba from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/taraskiba/skiba\n</code></pre>"},{"location":"interactive/","title":"interactive module","text":""},{"location":"interactive/#skiba.interactive.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>skiba/interactive.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[37.5, -95], zoom=4, height=\"600px\", **kwargs):\n        \"\"\"Initialize the map with a given center and zoom level.\n\n        Args:\n            center (list, optional): Center coordinates of the map. Defaults to [37.5, -95].\n            zoom (int, optional): Zoom level of the map. Defaults to 4.\n            height (str, optional): Height of the map. Defaults to \"600px\".\n            **kwargs: Additional keyword arguments for ipyleaflet.Map.\n        \"\"\"\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n        self.add_layer_control()\n        self.change_basemap()\n        self.add_search_marker()\n        self.upload_points()\n        self.upload_geojson_file()\n        self.change_built_in_shapefiles()\n        self.on_interaction(self.handle_click)\n        self.geojson_button()\n\n    def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def handle_click(self, **kwargs):\n        \"\"\"Handles click events on the map.\"\"\"\n        if kwargs.get(\"type\") == \"click\":\n            self.add_layer(ipyleaflet.Marker(location=kwargs.get(\"coordinates\")))\n\n            print(f\"Clicked at: {kwargs.get('coordinates')}\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_geojson(self, data, hover_style=None, **kwargs):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"gray\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        style = {\"color\": \"black\", \"weight\": 1, \"opacity\": 1}\n\n        if (\n            hasattr(self, \"current_geojson_layer\")\n            and self.current_geojson_layer is not None\n        ):\n            try:\n                self.remove_layer(self.current_geojson_layer)\n            except Exception:\n                pass  # Layer might have already been removed\n\n        layer = ipyleaflet.GeoJSON(\n            data=geojson, hover_style=hover_style, style=style, **kwargs\n        )\n        self.current_geojson_layer = layer\n        self.add_layer(layer)\n\n    def add_points(self, data, **kwargs):\n        \"\"\"Adds points to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n        \"\"\"\n\n        # Load data with safety checks\n        if isinstance(data, str):\n            coordinates = pd.read_csv(data)\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        elif isinstance(data, pd.DataFrame):\n            coordinates = data\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        else:\n            gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n        point_style = {\n            \"radius\": 2,\n            \"fillOpacity\": 1,\n            \"fillColor\": \"white\",\n            \"weight\": 1,\n        }  # 'color': 'white',\n\n        geo_data = ipyleaflet.GeoData(\n            geo_dataframe=gdf,\n            point_style=point_style,\n        )\n\n        self.add(geo_data)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def upload_points(self, **kwargs):\n        \"\"\"Uploads points to the map.\"\"\"\n\n        from ipywidgets import FileUpload, Button, ToggleButton, HBox\n\n        button = Button(\n            description=\"Add Points\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            size=38,\n            icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        file_upload = FileUpload(\n            accept=\".csv\",\n            multiple=False,\n            size=38,\n            description=\"Upload CSV\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        close_button = ToggleButton(\n            icon=\"map-pin\", value=True, tooltip=\"Upload points from CSV file\"\n        )\n        close_button.layout = widgets.Layout(width=\"36px\", height=\"36px\")\n\n        hbox = HBox([close_button])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if is_open[0] and change[\"new\"]:\n                hbox.children = (close_button,)\n            else:\n                hbox.children = (close_button, file_upload, button)\n\n        def on_button_clicked(change):\n            \"\"\"Handles the file upload.\"\"\"\n            import io\n\n            if file_upload.value:\n                # For the first file (if multiple=False)\n                file_info = file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()\n                points = pd.read_csv(io.BytesIO(content_bytes))\n                self.add_points(points)\n\n        close_button.observe(on_toggle_change, names=\"value\")\n\n        button.on_click(on_button_clicked)\n\n        upload_control = ipyleaflet.WidgetControl(widget=hbox, position=\"topright\")\n        self.add_control(upload_control)\n\n    def upload_geojson_file(self, **kwargs):\n        \"\"\"Uploads GeoJSON file to the map.\"\"\"\n\n        from ipywidgets import FileUpload, Button, ToggleButton, HBox\n\n        button = Button(\n            description=\"Add GeoJSON file\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            size=38,\n            icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        file_upload = FileUpload(\n            accept=\".geojson\",\n            multiple=False,\n            size=38,\n            description=\"Upload GeoJSON\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        close_button = ToggleButton(icon=\"file\", value=True, tooltip=\"Add GeoJSON file\")\n        close_button.layout = widgets.Layout(width=\"36px\", height=\"36px\")\n\n        hbox = HBox([close_button])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if change[\"new\"]:\n                hbox.children = (close_button,)\n            else:\n                hbox.children = (close_button, file_upload, button)\n\n        def on_button_clicked(change):\n            \"\"\"Handles the url upload.\"\"\"\n            if file_upload.value and len(file_upload.value) &gt; 0:\n                import json\n                from ipyleaflet import GeoJSON\n\n                file_info = file_upload.value[0]\n                # Get bytes from memoryview\n                content_bytes = file_info[\"content\"].tobytes()\n                # Decode bytes to string, then load as JSON\n                geojson_data = json.loads(content_bytes.decode(\"utf-8\"))\n                # Add the GeoJSON layer to the map\n                geo_json = GeoJSON(data=geojson_data)\n                self.add_layer(geo_json)\n\n        close_button.observe(on_toggle_change, names=\"value\")\n\n        button.on_click(on_button_clicked)\n\n        upload_control = ipyleaflet.WidgetControl(widget=hbox, position=\"topright\")\n        self.add_control(upload_control)\n\n    def add_widgets(self):\n        \"\"\"Creates and displays widgets for user interaction.\"\"\"\n\n        from ipywidgets import jslink\n        from ipyleaflet import WidgetControl\n\n        # date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n        opacity_slider = widgets.FloatSlider(\n            value=1,\n            min=0,\n            max=1.0,\n            step=0.01,\n            description=\"Opacity\",\n            continuous_update=False,\n            orientation=\"horizontal\",\n            readout=True,\n            readout_format=\".2f\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        basemap_layer = self.layers[1]\n        jslink((opacity_slider, \"value\"), (basemap_layer, \"opacity\"))\n        opacity_control = WidgetControl(widget=opacity_slider, position=\"topright\")\n\n        self.add(opacity_control)\n        # self.add(date_control)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def change_basemap(self, **kwargs):\n        \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n        from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n        from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n        # Map dropdown names to actual basemap objects\n        BASEMAP_LOOKUP = {\n            \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n            \"OpenTopoMap\": basemaps.OpenTopoMap,\n            \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n            \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n            \"CartoDB.Positron\": basemaps.CartoDB.Positron,\n            \"CartoDB.PositronNoLabels\": basemaps.CartoDB.PositronNoLabels,\n            \"Esri.WorldTopoMap\": basemaps.Esri.WorldTopoMap,\n            \"Esri.WorldStreetMap\": basemaps.Esri.WorldStreetMap,\n            \"Esri.OceanBasemap\": basemaps.Esri.OceanBasemap,\n            \"Esri.NatGeoWorldMap\": basemaps.Esri.NatGeoWorldMap,\n            \"NASAGIBS.ModisTerraTrueColorCR\": basemaps.NASAGIBS.ModisTerraTrueColorCR,\n            \"NASAGIBS.ModisAquaTrueColorCR\": basemaps.NASAGIBS.ModisAquaTrueColorCR,\n            \"NASAGIBS.ViirsTrueColorCR\": basemaps.NASAGIBS.ViirsTrueColorCR,\n            \"NASAGIBS.ViirsEarthAtNight2012\": basemaps.NASAGIBS.ViirsEarthAtNight2012,\n        }\n\n        # Create widgets\n\n        toggle = ToggleButton(\n            value=True,\n            tooltip=\"Change basemap\",\n            icon=\"map-o\",\n            layout=Layout(width=\"36px\", height=\"36px\"),\n        )\n\n        dropdown = Dropdown(\n            options=list(BASEMAP_LOOKUP.keys()),\n            value=\"OpenStreetMap\",\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n            layout=Layout(width=\"250px\", height=\"36px\"),\n        )\n\n        # Store reference to current basemap layer\n        if not hasattr(self, \"current_basemap\"):\n            self.current_basemap = self.layers[0]\n\n        def on_dropdown_change(change):\n            \"\"\"Handle basemap selection changes\"\"\"\n            if change[\"new\"]:\n                new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n                self.substitute_layer(self.current_basemap, new_basemap)\n                self.current_basemap = new_basemap\n\n        # def on_toggle_change(change):\n        #     \"\"\"Toggle visibility of dropdown\"\"\"\n        #     if change[\"new\"]:\n        #         dropdown.layout.visibility = 'visible'  # Show dropdown\n        #     else:\n        #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n        # Set up event handlers\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        # Assemble and add control\n        widget_box = HBox([toggle])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if is_open[0] and change[\"new\"]:\n                widget_box.children = (toggle,)\n            else:\n                widget_box.children = (toggle, dropdown)\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        control = WidgetControl(widget=widget_box, position=\"topright\")\n        self.add_control(control)\n\n    def change_built_in_shapefiles(self, **kwargs):\n        \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n        from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n        from ipyleaflet import WidgetControl\n\n        # Map dropdown names to actual basemap objects\n        SHAPEFILE_LOOKUP = {\n            \"None\": None,\n            \"U.S. States\": \"../data/us-states.json\",\n            \"National Forests\": \"https://geohub.oregon.gov/api/download/v1/items/b479e4bd7d70439a87e0230c99bddce5/geojson?layers=0\",\n        }\n\n        # Create widgets\n        toggle = ToggleButton(\n            value=True,\n            tooltip=\"Add built-in shapefile\",\n            icon=\"square-o\",\n            layout=Layout(width=\"38px\", height=\"38px\"),\n        )\n\n        dropdown = Dropdown(\n            options=list(SHAPEFILE_LOOKUP.keys()),\n            value=\"None\",\n            placeholder=\"Select a shapefile\",\n            description=\"Select shapefile:\",\n            style={\"description_width\": \"initial\"},\n            layout=Layout(width=\"250px\", height=\"38px\"),\n        )\n\n        # Store reference to current basemap layer\n        if not hasattr(self, \"current_basemap\"):\n            self.current_basemap = self.layers[0]\n\n        def on_dropdown_change(change):\n            \"\"\"Handle shapefile selection changes\"\"\"\n            if change[\"new\"]:\n                geojson_path = SHAPEFILE_LOOKUP[change[\"new\"]]\n                if geojson_path is not None:\n                    self.add_geojson(geojson_path, name=change[\"new\"])\n                else:\n                    # Remove existing shapefile layer if \"None\" is selected\n                    if (\n                        hasattr(self, \"current_geojson_layer\")\n                        and self.current_geojson_layer is not None\n                    ):\n                        try:\n                            self.remove_layer(self.current_geojson_layer)\n                        except Exception:\n                            pass\n\n        # Set up event handlers\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        # Assemble and add control\n        widget_box = HBox([toggle])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if is_open[0] and change[\"new\"]:\n                widget_box.children = (toggle,)\n            else:\n                widget_box.children = (toggle, dropdown)\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        control = WidgetControl(widget=widget_box, position=\"topright\")\n        self.add_control(control)\n\n    def add_search_marker(self, **kwargs):\n        \"\"\"Adds a search marker to the map.\"\"\"\n\n        from ipyleaflet import SearchControl, Marker, AwesomeIcon\n\n        search_marker = Marker(\n            icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\")\n        )\n\n        search_control = SearchControl(\n            position=\"topleft\",\n            url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\",\n            zoom=10,\n            marker=search_marker,\n        )\n\n        self.add(search_control)\n\n    def geojson_button(self, **kwargs):\n        \"\"\"Creates a button to add shapefiles.\"\"\"\n        from ipywidgets import Button, Text, ToggleButton, HBox, Layout\n        from ipyleaflet import WidgetControl\n\n        # Create widgets\n        toggle_close = ToggleButton(\n            value=True, tooltip=\"Add GeoJSON from link\", icon=\"link\"\n        )\n\n        url = Text(\n            placeholder=\"Type something\",\n            description=\"GeoJSON URL:\",\n            disabled=False,\n            style={\"description_width\": \"initial\"},\n        )\n\n        run_button = Button(\n            description=\"Add GeoJSON\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            size=38,\n            icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        toggle_close.layout = Layout(width=\"36px\", height=\"36px\")\n\n        # Assemble and add control\n        widget_box = HBox([toggle_close])\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if change[\"new\"]:\n                widget_box.children = (toggle_close,)\n            else:\n                widget_box.children = (toggle_close, url, run_button)\n\n        def on_button_clicked(change):\n            \"\"\"Handles the url upload.\"\"\"\n            if url.value:\n                # For the first file (if multiple=False)\n                geojson_path = url.value\n                self.add_geojson(geojson_path, name=url.value)\n\n        toggle_close.observe(on_toggle_change, names=\"value\")\n\n        run_button.on_click(on_button_clicked)\n\n        control = WidgetControl(widget=widget_box, position=\"topright\")\n\n        self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.__init__","title":"<code>__init__(self, center=[37.5, -95], zoom=4, height='600px', **kwargs)</code>  <code>special</code>","text":"<p>Initialize the map with a given center and zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>list</code> <p>Center coordinates of the map. Defaults to [37.5, -95].</p> <code>[37.5, -95]</code> <code>zoom</code> <code>int</code> <p>Zoom level of the map. Defaults to 4.</p> <code>4</code> <code>height</code> <code>str</code> <p>Height of the map. Defaults to \"600px\".</p> <code>'600px'</code> <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.Map.</p> <code>{}</code> Source code in <code>skiba/interactive.py</code> <pre><code>def __init__(self, center=[37.5, -95], zoom=4, height=\"600px\", **kwargs):\n    \"\"\"Initialize the map with a given center and zoom level.\n\n    Args:\n        center (list, optional): Center coordinates of the map. Defaults to [37.5, -95].\n        zoom (int, optional): Zoom level of the map. Defaults to 4.\n        height (str, optional): Height of the map. Defaults to \"600px\".\n        **kwargs: Additional keyword arguments for ipyleaflet.Map.\n    \"\"\"\n    super().__init__(center=center, zoom=zoom, **kwargs)\n    self.layout.height = height\n    self.scroll_wheel_zoom = True\n    self.add_layer_control()\n    self.change_basemap()\n    self.add_search_marker()\n    self.upload_points()\n    self.upload_geojson_file()\n    self.change_built_in_shapefiles()\n    self.on_interaction(self.handle_click)\n    self.geojson_button()\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_basemap","title":"<code>add_basemap(self, basemap='Esri.WorldImagery')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"Esri.WorldImagery\".</p> <code>'Esri.WorldImagery'</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_geojson","title":"<code>add_geojson(self, data, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> required <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_geojson(self, data, hover_style=None, **kwargs):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"gray\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    style = {\"color\": \"black\", \"weight\": 1, \"opacity\": 1}\n\n    if (\n        hasattr(self, \"current_geojson_layer\")\n        and self.current_geojson_layer is not None\n    ):\n        try:\n            self.remove_layer(self.current_geojson_layer)\n        except Exception:\n            pass  # Layer might have already been removed\n\n    layer = ipyleaflet.GeoJSON(\n        data=geojson, hover_style=hover_style, style=style, **kwargs\n    )\n    self.current_geojson_layer = layer\n    self.add_layer(layer)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_points","title":"<code>add_points(self, data, **kwargs)</code>","text":"<p>Adds points to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_points(self, data, **kwargs):\n    \"\"\"Adds points to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n    \"\"\"\n\n    # Load data with safety checks\n    if isinstance(data, str):\n        coordinates = pd.read_csv(data)\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    elif isinstance(data, pd.DataFrame):\n        coordinates = data\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    else:\n        gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n    point_style = {\n        \"radius\": 2,\n        \"fillOpacity\": 1,\n        \"fillColor\": \"white\",\n        \"weight\": 1,\n    }  # 'color': 'white',\n\n    geo_data = ipyleaflet.GeoData(\n        geo_dataframe=gdf,\n        point_style=point_style,\n    )\n\n    self.add(geo_data)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_search_marker","title":"<code>add_search_marker(self, **kwargs)</code>","text":"<p>Adds a search marker to the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_search_marker(self, **kwargs):\n    \"\"\"Adds a search marker to the map.\"\"\"\n\n    from ipyleaflet import SearchControl, Marker, AwesomeIcon\n\n    search_marker = Marker(\n        icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\")\n    )\n\n    search_control = SearchControl(\n        position=\"topleft\",\n        url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\",\n        zoom=10,\n        marker=search_marker,\n    )\n\n    self.add(search_control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_widgets","title":"<code>add_widgets(self)</code>","text":"<p>Creates and displays widgets for user interaction.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_widgets(self):\n    \"\"\"Creates and displays widgets for user interaction.\"\"\"\n\n    from ipywidgets import jslink\n    from ipyleaflet import WidgetControl\n\n    # date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n    opacity_slider = widgets.FloatSlider(\n        value=1,\n        min=0,\n        max=1.0,\n        step=0.01,\n        description=\"Opacity\",\n        continuous_update=False,\n        orientation=\"horizontal\",\n        readout=True,\n        readout_format=\".2f\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    basemap_layer = self.layers[1]\n    jslink((opacity_slider, \"value\"), (basemap_layer, \"opacity\"))\n    opacity_control = WidgetControl(widget=opacity_slider, position=\"topright\")\n\n    self.add(opacity_control)\n    # self.add(date_control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.change_basemap","title":"<code>change_basemap(self, **kwargs)</code>","text":"<p>Changes the basemap of the map using a dropdown selector.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def change_basemap(self, **kwargs):\n    \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n    from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n    from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n    # Map dropdown names to actual basemap objects\n    BASEMAP_LOOKUP = {\n        \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n        \"OpenTopoMap\": basemaps.OpenTopoMap,\n        \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n        \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n        \"CartoDB.Positron\": basemaps.CartoDB.Positron,\n        \"CartoDB.PositronNoLabels\": basemaps.CartoDB.PositronNoLabels,\n        \"Esri.WorldTopoMap\": basemaps.Esri.WorldTopoMap,\n        \"Esri.WorldStreetMap\": basemaps.Esri.WorldStreetMap,\n        \"Esri.OceanBasemap\": basemaps.Esri.OceanBasemap,\n        \"Esri.NatGeoWorldMap\": basemaps.Esri.NatGeoWorldMap,\n        \"NASAGIBS.ModisTerraTrueColorCR\": basemaps.NASAGIBS.ModisTerraTrueColorCR,\n        \"NASAGIBS.ModisAquaTrueColorCR\": basemaps.NASAGIBS.ModisAquaTrueColorCR,\n        \"NASAGIBS.ViirsTrueColorCR\": basemaps.NASAGIBS.ViirsTrueColorCR,\n        \"NASAGIBS.ViirsEarthAtNight2012\": basemaps.NASAGIBS.ViirsEarthAtNight2012,\n    }\n\n    # Create widgets\n\n    toggle = ToggleButton(\n        value=True,\n        tooltip=\"Change basemap\",\n        icon=\"map-o\",\n        layout=Layout(width=\"36px\", height=\"36px\"),\n    )\n\n    dropdown = Dropdown(\n        options=list(BASEMAP_LOOKUP.keys()),\n        value=\"OpenStreetMap\",\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n        layout=Layout(width=\"250px\", height=\"36px\"),\n    )\n\n    # Store reference to current basemap layer\n    if not hasattr(self, \"current_basemap\"):\n        self.current_basemap = self.layers[0]\n\n    def on_dropdown_change(change):\n        \"\"\"Handle basemap selection changes\"\"\"\n        if change[\"new\"]:\n            new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n            self.substitute_layer(self.current_basemap, new_basemap)\n            self.current_basemap = new_basemap\n\n    # def on_toggle_change(change):\n    #     \"\"\"Toggle visibility of dropdown\"\"\"\n    #     if change[\"new\"]:\n    #         dropdown.layout.visibility = 'visible'  # Show dropdown\n    #     else:\n    #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n    # Set up event handlers\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    # Assemble and add control\n    widget_box = HBox([toggle])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if is_open[0] and change[\"new\"]:\n            widget_box.children = (toggle,)\n        else:\n            widget_box.children = (toggle, dropdown)\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    control = WidgetControl(widget=widget_box, position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.change_built_in_shapefiles","title":"<code>change_built_in_shapefiles(self, **kwargs)</code>","text":"<p>Changes the basemap of the map using a dropdown selector.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def change_built_in_shapefiles(self, **kwargs):\n    \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n    from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n    from ipyleaflet import WidgetControl\n\n    # Map dropdown names to actual basemap objects\n    SHAPEFILE_LOOKUP = {\n        \"None\": None,\n        \"U.S. States\": \"../data/us-states.json\",\n        \"National Forests\": \"https://geohub.oregon.gov/api/download/v1/items/b479e4bd7d70439a87e0230c99bddce5/geojson?layers=0\",\n    }\n\n    # Create widgets\n    toggle = ToggleButton(\n        value=True,\n        tooltip=\"Add built-in shapefile\",\n        icon=\"square-o\",\n        layout=Layout(width=\"38px\", height=\"38px\"),\n    )\n\n    dropdown = Dropdown(\n        options=list(SHAPEFILE_LOOKUP.keys()),\n        value=\"None\",\n        placeholder=\"Select a shapefile\",\n        description=\"Select shapefile:\",\n        style={\"description_width\": \"initial\"},\n        layout=Layout(width=\"250px\", height=\"38px\"),\n    )\n\n    # Store reference to current basemap layer\n    if not hasattr(self, \"current_basemap\"):\n        self.current_basemap = self.layers[0]\n\n    def on_dropdown_change(change):\n        \"\"\"Handle shapefile selection changes\"\"\"\n        if change[\"new\"]:\n            geojson_path = SHAPEFILE_LOOKUP[change[\"new\"]]\n            if geojson_path is not None:\n                self.add_geojson(geojson_path, name=change[\"new\"])\n            else:\n                # Remove existing shapefile layer if \"None\" is selected\n                if (\n                    hasattr(self, \"current_geojson_layer\")\n                    and self.current_geojson_layer is not None\n                ):\n                    try:\n                        self.remove_layer(self.current_geojson_layer)\n                    except Exception:\n                        pass\n\n    # Set up event handlers\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    # Assemble and add control\n    widget_box = HBox([toggle])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if is_open[0] and change[\"new\"]:\n            widget_box.children = (toggle,)\n        else:\n            widget_box.children = (toggle, dropdown)\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    control = WidgetControl(widget=widget_box, position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.geojson_button","title":"<code>geojson_button(self, **kwargs)</code>","text":"<p>Creates a button to add shapefiles.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def geojson_button(self, **kwargs):\n    \"\"\"Creates a button to add shapefiles.\"\"\"\n    from ipywidgets import Button, Text, ToggleButton, HBox, Layout\n    from ipyleaflet import WidgetControl\n\n    # Create widgets\n    toggle_close = ToggleButton(\n        value=True, tooltip=\"Add GeoJSON from link\", icon=\"link\"\n    )\n\n    url = Text(\n        placeholder=\"Type something\",\n        description=\"GeoJSON URL:\",\n        disabled=False,\n        style={\"description_width\": \"initial\"},\n    )\n\n    run_button = Button(\n        description=\"Add GeoJSON\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        size=38,\n        icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    toggle_close.layout = Layout(width=\"36px\", height=\"36px\")\n\n    # Assemble and add control\n    widget_box = HBox([toggle_close])\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if change[\"new\"]:\n            widget_box.children = (toggle_close,)\n        else:\n            widget_box.children = (toggle_close, url, run_button)\n\n    def on_button_clicked(change):\n        \"\"\"Handles the url upload.\"\"\"\n        if url.value:\n            # For the first file (if multiple=False)\n            geojson_path = url.value\n            self.add_geojson(geojson_path, name=url.value)\n\n    toggle_close.observe(on_toggle_change, names=\"value\")\n\n    run_button.on_click(on_button_clicked)\n\n    control = WidgetControl(widget=widget_box, position=\"topright\")\n\n    self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.handle_click","title":"<code>handle_click(self, **kwargs)</code>","text":"<p>Handles click events on the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def handle_click(self, **kwargs):\n    \"\"\"Handles click events on the map.\"\"\"\n    if kwargs.get(\"type\") == \"click\":\n        self.add_layer(ipyleaflet.Marker(location=kwargs.get(\"coordinates\")))\n\n        print(f\"Clicked at: {kwargs.get('coordinates')}\")\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.upload_geojson_file","title":"<code>upload_geojson_file(self, **kwargs)</code>","text":"<p>Uploads GeoJSON file to the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def upload_geojson_file(self, **kwargs):\n    \"\"\"Uploads GeoJSON file to the map.\"\"\"\n\n    from ipywidgets import FileUpload, Button, ToggleButton, HBox\n\n    button = Button(\n        description=\"Add GeoJSON file\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        size=38,\n        icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    file_upload = FileUpload(\n        accept=\".geojson\",\n        multiple=False,\n        size=38,\n        description=\"Upload GeoJSON\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    close_button = ToggleButton(icon=\"file\", value=True, tooltip=\"Add GeoJSON file\")\n    close_button.layout = widgets.Layout(width=\"36px\", height=\"36px\")\n\n    hbox = HBox([close_button])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if change[\"new\"]:\n            hbox.children = (close_button,)\n        else:\n            hbox.children = (close_button, file_upload, button)\n\n    def on_button_clicked(change):\n        \"\"\"Handles the url upload.\"\"\"\n        if file_upload.value and len(file_upload.value) &gt; 0:\n            import json\n            from ipyleaflet import GeoJSON\n\n            file_info = file_upload.value[0]\n            # Get bytes from memoryview\n            content_bytes = file_info[\"content\"].tobytes()\n            # Decode bytes to string, then load as JSON\n            geojson_data = json.loads(content_bytes.decode(\"utf-8\"))\n            # Add the GeoJSON layer to the map\n            geo_json = GeoJSON(data=geojson_data)\n            self.add_layer(geo_json)\n\n    close_button.observe(on_toggle_change, names=\"value\")\n\n    button.on_click(on_button_clicked)\n\n    upload_control = ipyleaflet.WidgetControl(widget=hbox, position=\"topright\")\n    self.add_control(upload_control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.upload_points","title":"<code>upload_points(self, **kwargs)</code>","text":"<p>Uploads points to the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def upload_points(self, **kwargs):\n    \"\"\"Uploads points to the map.\"\"\"\n\n    from ipywidgets import FileUpload, Button, ToggleButton, HBox\n\n    button = Button(\n        description=\"Add Points\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        size=38,\n        icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    file_upload = FileUpload(\n        accept=\".csv\",\n        multiple=False,\n        size=38,\n        description=\"Upload CSV\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    close_button = ToggleButton(\n        icon=\"map-pin\", value=True, tooltip=\"Upload points from CSV file\"\n    )\n    close_button.layout = widgets.Layout(width=\"36px\", height=\"36px\")\n\n    hbox = HBox([close_button])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if is_open[0] and change[\"new\"]:\n            hbox.children = (close_button,)\n        else:\n            hbox.children = (close_button, file_upload, button)\n\n    def on_button_clicked(change):\n        \"\"\"Handles the file upload.\"\"\"\n        import io\n\n        if file_upload.value:\n            # For the first file (if multiple=False)\n            file_info = file_upload.value[0]\n            content_bytes = file_info[\"content\"].tobytes()\n            points = pd.read_csv(io.BytesIO(content_bytes))\n            self.add_points(points)\n\n    close_button.observe(on_toggle_change, names=\"value\")\n\n    button.on_click(on_button_clicked)\n\n    upload_control = ipyleaflet.WidgetControl(widget=hbox, position=\"topright\")\n    self.add_control(upload_control)\n</code></pre>"},{"location":"ipyleafletcode/","title":"ipyleaflet code","text":"<p>Main module.</p>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def handle_click(self, **kwargs):\n        import ipywidgets as widgets\n\n        if kwargs.get(\"type\") == \"click\":\n            self.add_layer(widgets.Marker(location=kwargs.get(\"coordinates\")))\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_raster(self, filepath, **kwargs):\n        \"\"\"Add GeoTIFF raster to the map.\n\n        Args:\n            filepath (_type_): _description_\n        \"\"\"\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        client = TileClient(filepath)\n        tile_layer = get_leaflet_tile_layer(client, **kwargs)\n\n        self.add(tile_layer)\n        self.center = client.center()\n        self.zoom = client.default_zoom\n\n    def add_image(self, image, bounds=None, **kwargs):\n        \"\"\"Adds an image to the map.\n\n        Args:\n            image (str): The file path to the image.\n            bounds (list, optional): The bounds for the image. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    def add_video(self, video, bounds=None, **kwargs):\n        \"\"\"Adds a video to the map.\n\n        Args:\n            video (str): The file path to the video.\n            bounds (list, optional): The bounds for the video. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    def add_wms_layer(\n        self, url, layers, format=\"image/png\", transparent=True, **kwargs\n    ):\n        \"\"\"Adds a WMS layer to the map.\n\n        Args:\n            url (str): The WMS service URL.\n            layers (str): The layers to display.\n            **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n        \"\"\"\n        layer = ipyleaflet.WMSLayer(\n            url=url, layers=layers, format=format, transparent=transparent, **kwargs\n        )\n\n        self.add(layer)\n\n    def change_basemap(self, **kwargs):\n        \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n        from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n        from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n        # Map dropdown names to actual basemap objects\n        BASEMAP_LOOKUP = {\n            \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n            \"OpenTopoMap\": basemaps.OpenTopoMap,\n            \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n            \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n        }\n\n        # Create widgets\n        toggle = ToggleButton(\n            value=True,\n            tooltip=\"Toggle basemap selector\",\n            icon=\"map\",\n            layout=Layout(width=\"38px\", height=\"38px\"),\n        )\n\n        dropdown = Dropdown(\n            options=list(BASEMAP_LOOKUP.keys()),\n            value=\"OpenStreetMap\",\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n            layout=Layout(width=\"250px\", height=\"38px\"),\n        )\n\n        # Store reference to current basemap layer\n        if not hasattr(self, \"current_basemap\"):\n            self.current_basemap = self.layers[0]\n\n        def on_dropdown_change(change):\n            \"\"\"Handle basemap selection changes\"\"\"\n            if change[\"new\"]:\n                new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n                self.substitute_layer(self.current_basemap, new_basemap)\n                self.current_basemap = new_basemap\n\n        # def on_toggle_change(change):\n        #     \"\"\"Toggle visibility of dropdown\"\"\"\n        #     if change[\"new\"]:\n        #         dropdown.layout.visibility = 'visible'  # Show dropdown\n        #     else:\n        #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n        # Set up event handlers\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        # Assemble and add control\n        widget_box = HBox([toggle, dropdown])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if is_open[0] and change[\"new\"]:\n                widget_box.children = (toggle, dropdown)\n            else:\n                widget_box.children = (toggle,)\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        control = WidgetControl(widget=widget_box, position=\"topright\")\n        self.add_control(control)\n\n    def add_search_marker(self, **kwargs):\n        \"\"\"Adds a search marker to the map.\"\"\"\n\n        from ipyleaflet import Map, SearchControl, Marker, AwesomeIcon\n\n        search_marker = Marker(\n            icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\")\n        )\n\n        search_control = SearchControl(\n            position=\"topleft\",\n            url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\",\n            zoom=10,\n            marker=search_marker,\n        )\n\n        self.add(search_control)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_image","title":"<code>add_image(self, image, bounds=None, **kwargs)</code>","text":"<p>Adds an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The file path to the image.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the image. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.ImageOverlay layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_image(self, image, bounds=None, **kwargs):\n    \"\"\"Adds an image to the map.\n\n    Args:\n        image (str): The file path to the image.\n        bounds (list, optional): The bounds for the image. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_raster","title":"<code>add_raster(self, filepath, **kwargs)</code>","text":"<p>Add GeoTIFF raster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>_type_</code> <p>description</p> required Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_raster(self, filepath, **kwargs):\n    \"\"\"Add GeoTIFF raster to the map.\n\n    Args:\n        filepath (_type_): _description_\n    \"\"\"\n    from localtileserver import TileClient, get_leaflet_tile_layer\n\n    client = TileClient(filepath)\n    tile_layer = get_leaflet_tile_layer(client, **kwargs)\n\n    self.add(tile_layer)\n    self.center = client.center()\n    self.zoom = client.default_zoom\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_search_marker","title":"<code>add_search_marker(self, **kwargs)</code>","text":"<p>Adds a search marker to the map.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_search_marker(self, **kwargs):\n    \"\"\"Adds a search marker to the map.\"\"\"\n\n    from ipyleaflet import Map, SearchControl, Marker, AwesomeIcon\n\n    search_marker = Marker(\n        icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\")\n    )\n\n    search_control = SearchControl(\n        position=\"topleft\",\n        url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\",\n        zoom=10,\n        marker=search_marker,\n    )\n\n    self.add(search_control)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_video","title":"<code>add_video(self, video, bounds=None, **kwargs)</code>","text":"<p>Adds a video to the map.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>str</code> <p>The file path to the video.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the video. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.VideoOverlay layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_video(self, video, bounds=None, **kwargs):\n    \"\"\"Adds a video to the map.\n\n    Args:\n        video (str): The file path to the video.\n        bounds (list, optional): The bounds for the video. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, format='image/png', transparent=True, **kwargs)</code>","text":"<p>Adds a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The WMS service URL.</p> required <code>layers</code> <code>str</code> <p>The layers to display.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.WMSLayer layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_wms_layer(\n    self, url, layers, format=\"image/png\", transparent=True, **kwargs\n):\n    \"\"\"Adds a WMS layer to the map.\n\n    Args:\n        url (str): The WMS service URL.\n        layers (str): The layers to display.\n        **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n    \"\"\"\n    layer = ipyleaflet.WMSLayer(\n        url=url, layers=layers, format=format, transparent=transparent, **kwargs\n    )\n\n    self.add(layer)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.change_basemap","title":"<code>change_basemap(self, **kwargs)</code>","text":"<p>Changes the basemap of the map using a dropdown selector.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def change_basemap(self, **kwargs):\n    \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n    from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n    from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n    # Map dropdown names to actual basemap objects\n    BASEMAP_LOOKUP = {\n        \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n        \"OpenTopoMap\": basemaps.OpenTopoMap,\n        \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n        \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n    }\n\n    # Create widgets\n    toggle = ToggleButton(\n        value=True,\n        tooltip=\"Toggle basemap selector\",\n        icon=\"map\",\n        layout=Layout(width=\"38px\", height=\"38px\"),\n    )\n\n    dropdown = Dropdown(\n        options=list(BASEMAP_LOOKUP.keys()),\n        value=\"OpenStreetMap\",\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n        layout=Layout(width=\"250px\", height=\"38px\"),\n    )\n\n    # Store reference to current basemap layer\n    if not hasattr(self, \"current_basemap\"):\n        self.current_basemap = self.layers[0]\n\n    def on_dropdown_change(change):\n        \"\"\"Handle basemap selection changes\"\"\"\n        if change[\"new\"]:\n            new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n            self.substitute_layer(self.current_basemap, new_basemap)\n            self.current_basemap = new_basemap\n\n    # def on_toggle_change(change):\n    #     \"\"\"Toggle visibility of dropdown\"\"\"\n    #     if change[\"new\"]:\n    #         dropdown.layout.visibility = 'visible'  # Show dropdown\n    #     else:\n    #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n    # Set up event handlers\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    # Assemble and add control\n    widget_box = HBox([toggle, dropdown])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if is_open[0] and change[\"new\"]:\n            widget_box.children = (toggle, dropdown)\n        else:\n            widget_box.children = (toggle,)\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    control = WidgetControl(widget=widget_box, position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"map_detail/","title":"map_detail module","text":""},{"location":"map_detail/#skiba.map_detail.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>skiba/map_detail.py</code> <pre><code>class Map(ipyleaflet.Map):\n\n    def __init__(self, center=[37.5, -95], zoom=4, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_geojson(\n        self,\n        data,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"gray\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        style = {\"color\": \"black\", \"weight\": 1, \"opacity\": 1}\n\n        layer = ipyleaflet.GeoJSON(\n            data=geojson, hover_style=hover_style, style=style, **kwargs\n        )\n        self.add_layer(layer)\n\n    def add_points(self, data, **kwargs):\n        \"\"\"Adds points to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n        \"\"\"\n\n        # Load data with safety checks\n        if isinstance(data, str):\n            coordinates = pd.read_csv(data)\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        else:\n            gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n        point_style = {\n            \"radius\": 5,\n            \"fillOpacity\": 1,\n            \"fillColor\": \"white\",\n            \"weight\": 1,\n        }  # 'color': 'white',\n\n        geo_data = ipyleaflet.GeoData(\n            geo_dataframe=gdf,\n            point_style=point_style,\n        )\n\n        self.add(geo_data)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_widgets(self):\n        \"\"\"Creates and displays widgets for user interaction.\"\"\"\n\n        from ipywidgets import jslink\n        from ipyleaflet import WidgetControl\n\n        # date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n        opacity_slider = widgets.FloatSlider(\n            value=1,\n            min=0,\n            max=1.0,\n            step=0.01,\n            description=\"Opacity\",\n            continuous_update=False,\n            orientation=\"horizontal\",\n            readout=True,\n            readout_format=\".2f\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        basemap_layer = self.layers[1]\n        jslink((opacity_slider, \"value\"), (basemap_layer, \"opacity\"))\n        opacity_control = WidgetControl(widget=opacity_slider, position=\"topright\")\n\n        self.add(opacity_control)\n        # self.add(date_control)\n\n    def change_basemap(self, **kwargs):\n        \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n        from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n        from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n        # Map dropdown names to actual basemap objects\n        BASEMAP_LOOKUP = {\n            \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n            \"OpenTopoMap\": basemaps.OpenTopoMap,\n            \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n            \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n        }\n\n        # Create widgets\n        toggle = ToggleButton(\n            value=True,\n            tooltip=\"Toggle basemap selector\",\n            icon=\"map\",\n            layout=Layout(width=\"38px\", height=\"38px\"),\n        )\n\n        dropdown = Dropdown(\n            options=list(BASEMAP_LOOKUP.keys()),\n            value=\"OpenStreetMap\",\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n            layout=Layout(width=\"250px\", height=\"38px\"),\n        )\n\n        # Store reference to current basemap layer\n        if not hasattr(self, \"current_basemap\"):\n            self.current_basemap = self.layers[0]\n\n        def on_dropdown_change(change):\n            \"\"\"Handle basemap selection changes\"\"\"\n            if change[\"new\"]:\n                new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n                self.substitute_layer(self.current_basemap, new_basemap)\n                self.current_basemap = new_basemap\n\n        # def on_toggle_change(change):\n        #     \"\"\"Toggle visibility of dropdown\"\"\"\n        #     if change[\"new\"]:\n        #         dropdown.layout.visibility = 'visible'  # Show dropdown\n        #     else:\n        #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n        # Set up event handlers\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        # Assemble and add control\n        widget_box = HBox([toggle, dropdown])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if is_open[0] and change[\"new\"]:\n                widget_box.children = (toggle, dropdown)\n            else:\n                widget_box.children = (toggle,)\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        control = WidgetControl(widget=widget_box, position=\"topright\")\n        self.add_control(control)\n\n    # Using geemap, ipyleaflet, and ipywidgets create a map with a dropdown menu that has any Google Earth Engine dataset\n</code></pre>"},{"location":"map_detail/#skiba.map_detail.Map.add_basemap","title":"<code>add_basemap(self, basemap='Esri.WorldImagery')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"Esri.WorldImagery\".</p> <code>'Esri.WorldImagery'</code> Source code in <code>skiba/map_detail.py</code> <pre><code>def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"map_detail/#skiba.map_detail.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/map_detail.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"map_detail/#skiba.map_detail.Map.add_geojson","title":"<code>add_geojson(self, data, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> required <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/map_detail.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"gray\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    style = {\"color\": \"black\", \"weight\": 1, \"opacity\": 1}\n\n    layer = ipyleaflet.GeoJSON(\n        data=geojson, hover_style=hover_style, style=style, **kwargs\n    )\n    self.add_layer(layer)\n</code></pre>"},{"location":"map_detail/#skiba.map_detail.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>skiba/map_detail.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"map_detail/#skiba.map_detail.Map.add_points","title":"<code>add_points(self, data, **kwargs)</code>","text":"<p>Adds points to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/map_detail.py</code> <pre><code>def add_points(self, data, **kwargs):\n    \"\"\"Adds points to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n    \"\"\"\n\n    # Load data with safety checks\n    if isinstance(data, str):\n        coordinates = pd.read_csv(data)\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    else:\n        gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n    point_style = {\n        \"radius\": 5,\n        \"fillOpacity\": 1,\n        \"fillColor\": \"white\",\n        \"weight\": 1,\n    }  # 'color': 'white',\n\n    geo_data = ipyleaflet.GeoData(\n        geo_dataframe=gdf,\n        point_style=point_style,\n    )\n\n    self.add(geo_data)\n</code></pre>"},{"location":"map_detail/#skiba.map_detail.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/map_detail.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"map_detail/#skiba.map_detail.Map.add_widgets","title":"<code>add_widgets(self)</code>","text":"<p>Creates and displays widgets for user interaction.</p> Source code in <code>skiba/map_detail.py</code> <pre><code>def add_widgets(self):\n    \"\"\"Creates and displays widgets for user interaction.\"\"\"\n\n    from ipywidgets import jslink\n    from ipyleaflet import WidgetControl\n\n    # date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n    opacity_slider = widgets.FloatSlider(\n        value=1,\n        min=0,\n        max=1.0,\n        step=0.01,\n        description=\"Opacity\",\n        continuous_update=False,\n        orientation=\"horizontal\",\n        readout=True,\n        readout_format=\".2f\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    basemap_layer = self.layers[1]\n    jslink((opacity_slider, \"value\"), (basemap_layer, \"opacity\"))\n    opacity_control = WidgetControl(widget=opacity_slider, position=\"topright\")\n\n    self.add(opacity_control)\n    # self.add(date_control)\n</code></pre>"},{"location":"map_detail/#skiba.map_detail.Map.change_basemap","title":"<code>change_basemap(self, **kwargs)</code>","text":"<p>Changes the basemap of the map using a dropdown selector.</p> Source code in <code>skiba/map_detail.py</code> <pre><code>def change_basemap(self, **kwargs):\n    \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n    from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n    from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n    # Map dropdown names to actual basemap objects\n    BASEMAP_LOOKUP = {\n        \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n        \"OpenTopoMap\": basemaps.OpenTopoMap,\n        \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n        \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n    }\n\n    # Create widgets\n    toggle = ToggleButton(\n        value=True,\n        tooltip=\"Toggle basemap selector\",\n        icon=\"map\",\n        layout=Layout(width=\"38px\", height=\"38px\"),\n    )\n\n    dropdown = Dropdown(\n        options=list(BASEMAP_LOOKUP.keys()),\n        value=\"OpenStreetMap\",\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n        layout=Layout(width=\"250px\", height=\"38px\"),\n    )\n\n    # Store reference to current basemap layer\n    if not hasattr(self, \"current_basemap\"):\n        self.current_basemap = self.layers[0]\n\n    def on_dropdown_change(change):\n        \"\"\"Handle basemap selection changes\"\"\"\n        if change[\"new\"]:\n            new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n            self.substitute_layer(self.current_basemap, new_basemap)\n            self.current_basemap = new_basemap\n\n    # def on_toggle_change(change):\n    #     \"\"\"Toggle visibility of dropdown\"\"\"\n    #     if change[\"new\"]:\n    #         dropdown.layout.visibility = 'visible'  # Show dropdown\n    #     else:\n    #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n    # Set up event handlers\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    # Assemble and add control\n    widget_box = HBox([toggle, dropdown])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if is_open[0] and change[\"new\"]:\n            widget_box.children = (toggle, dropdown)\n        else:\n            widget_box.children = (toggle,)\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    control = WidgetControl(widget=widget_box, position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"skiba/","title":"skiba module","text":"<p>Main module.</p>"},{"location":"usage/","title":"Usage","text":"<p>To use skiba in a project:</p> <pre><code>import skiba\n</code></pre>"},{"location":"examples/buffer_method/","title":"Buffer method","text":"In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap as gm\nimport pandas as pd\nimport geopandas as gpd\nfrom shapely.geometry import Point\nimport os\n\n# Initialize Earth Engine\nee.Authenticate()\nee.Initialize()\n</pre> import ee import geemap as gm import pandas as pd import geopandas as gpd from shapely.geometry import Point import os  # Initialize Earth Engine ee.Authenticate() ee.Initialize() In\u00a0[\u00a0]: Copied! <pre>import skiba.buffer_coordinates as bc\nimport skiba.buffer_method as bm\n</pre> import skiba.buffer_coordinates as bc import skiba.buffer_method as bm In\u00a0[\u00a0]: Copied! <pre>widget = bc.buffer_coordinates().vbox\nwidget\n</pre> widget = bc.buffer_coordinates().vbox widget In\u00a0[\u00a0]: Copied! <pre>m = bm.buffer_method().vbox\nm\n</pre> m = bm.buffer_method().vbox m In\u00a0[\u00a0]: Copied! <pre>import skiba.interactive as interactive\n\nmap = interactive.Map()\n# path = \"../data/5000.0.geojson\"\n# map.add_geojson(path)\n# path1 = \"../data/selected_coordinates.csv\"\n# map.add_points(path1)\nmap\n</pre> import skiba.interactive as interactive  map = interactive.Map() # path = \"../data/5000.0.geojson\" # map.add_geojson(path) # path1 = \"../data/selected_coordinates.csv\" # map.add_points(path1) map"},{"location":"examples/data_process_demo/","title":"Data process demo","text":"<p>\"\"</p> In\u00a0[\u00a0]: Copied! <pre># !pip install skiba # uncomment if need to install the package\nimport skiba.data_process as sdp\nimport ee\n\nee.Authenticate()\nee.Initialize()\n\n\n# import ee\n</pre> # !pip install skiba # uncomment if need to install the package import skiba.data_process as sdp import ee  ee.Authenticate() ee.Initialize()   # import ee In\u00a0[\u00a0]: Copied! <pre>m = sdp.data_process().vbox\nm\n</pre> m = sdp.data_process().vbox m"},{"location":"examples/data_process_demo/#import-package","title":"Import package\u00b6","text":""},{"location":"examples/data_process_demo/#run-widget","title":"Run widget\u00b6","text":""},{"location":"examples/data_process_full_walkthrough/","title":"Data process full walkthrough","text":"<p>\"\"</p> In\u00a0[\u00a0]: Copied! <pre># !pip install skiba # uncomment if need to install the package\nimport skiba.data_process as sdp\n\n# import ee\n</pre> # !pip install skiba # uncomment if need to install the package import skiba.data_process as sdp  # import ee In\u00a0[\u00a0]: Copied! <pre>m = sdp.data_process\ndropdown_widget = m.create_dropdown()\ndropdown_widget\n</pre> m = sdp.data_process dropdown_widget = m.create_dropdown() dropdown_widget In\u00a0[\u00a0]: Copied! <pre>m1 = sdp.data_process\nstart = m1.add_date_picker()\nstart\n</pre> m1 = sdp.data_process start = m1.add_date_picker() start In\u00a0[\u00a0]: Copied! <pre>end = m1.add_date_picker()\nend\n</pre> end = m1.add_date_picker() end In\u00a0[\u00a0]: Copied! <pre># Using sample data set of FIA plots located in the national forests and parks of southeast Appalachia.\npoints = \"../data/selected_coordinates.csv\"\ngeedata = dropdown_widget.value\nend_date = end.value\nstart_date = start.value\n</pre> # Using sample data set of FIA plots located in the national forests and parks of southeast Appalachia. points = \"../data/selected_coordinates.csv\" geedata = dropdown_widget.value end_date = end.value start_date = start.value In\u00a0[\u00a0]: Copied! <pre>final = sdp.data_process\nreturned_dataset = final.get_coordinate_data(\n    data=points, geedata=geedata, start_date=start_date, end_date=end_date\n)\n</pre> final = sdp.data_process returned_dataset = final.get_coordinate_data(     data=points, geedata=geedata, start_date=start_date, end_date=end_date )"},{"location":"examples/data_process_full_walkthrough/#import-package","title":"Import package\u00b6","text":""},{"location":"examples/data_process_full_walkthrough/#select-gee-data-set","title":"Select GEE data set\u00b6","text":""},{"location":"examples/data_process_full_walkthrough/#add-start-and-end-dates-optional","title":"Add start and end dates (optional)\u00b6","text":""},{"location":"examples/data_process_full_walkthrough/#start-date","title":"Start date\u00b6","text":""},{"location":"examples/data_process_full_walkthrough/#end-date","title":"End date\u00b6","text":""},{"location":"examples/data_process_full_walkthrough/#add-dataset-of-coordinate-points","title":"Add dataset of coordinate points\u00b6","text":"<p>You must run this section before extracting values</p>"},{"location":"examples/data_process_full_walkthrough/#extract-values-from-gee-bands-for-provided-coordinates","title":"Extract values from GEE bands for provided coordinates.\u00b6","text":"<p>Will return as a csv file in ~/Downloads under the Earth Engine Snippet name.</p>"},{"location":"examples/folium_demo/","title":"Folium demo","text":"<p>\"\"</p> In\u00a0[\u00a0]: Copied! <pre>import skiba.foliumcode as skiba\n</pre> import skiba.foliumcode as skiba In\u00a0[\u00a0]: Copied! <pre>m = skiba.Map(center=[37.5, -95], zoom=4)\nurl = \"https://data-usfs.hub.arcgis.com/api/download/v1/items/4a48c9a7ad3144f7890ff85d5dd76f1e/geojson?layers=2\"\nm.add_geojson(url)\nm.add_split_map(left=\"Esri.WorldImagery\", right=\"openstreetmap\")\nm.add_layer_control()\nm\n</pre> m = skiba.Map(center=[37.5, -95], zoom=4) url = \"https://data-usfs.hub.arcgis.com/api/download/v1/items/4a48c9a7ad3144f7890ff85d5dd76f1e/geojson?layers=2\" m.add_geojson(url) m.add_split_map(left=\"Esri.WorldImagery\", right=\"openstreetmap\") m.add_layer_control() m In\u00a0[\u00a0]: Copied! <pre>m2 = skiba.Map(center=[32.765745, 22.643689], zoom=4)\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nurl2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\nm2.add_split_map(url, url2)\nm2\n</pre> m2 = skiba.Map(center=[32.765745, 22.643689], zoom=4) url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\" m2.add_split_map(url, url2) m2"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[\u00a0]: Copied! <pre>print(\"Hello World!\")\n\nprint(\"Goodbye World!\")\n</pre> print(\"Hello World!\")  print(\"Goodbye World!\")"},{"location":"examples/ipyleaflet_demo/","title":"Ipyleaflet demo","text":"<p>\"\"</p> In\u00a0[\u00a0]: Copied! <pre>import skiba.ipyleafletcode as skibaipy\n\nskibaipy.Map\n</pre> import skiba.ipyleafletcode as skibaipy  skibaipy.Map In\u00a0[\u00a0]: Copied! <pre>m = skibaipy.Map(center=[37.5, -95], zoom=4)\nurl = \"https://github.com/opengeos/datasets/releases/download/vector/hike.geojson\"\nm.add_geojson(url)\n# m.add_basemap(\"Esri.WorldImagery\")\nm.add_layer_control()\nm\n</pre> m = skibaipy.Map(center=[37.5, -95], zoom=4) url = \"https://github.com/opengeos/datasets/releases/download/vector/hike.geojson\" m.add_geojson(url) # m.add_basemap(\"Esri.WorldImagery\") m.add_layer_control() m In\u00a0[\u00a0]: Copied! <pre>m.change_basemap()\n</pre> m.change_basemap()"},{"location":"examples/lab9/","title":"Lab9","text":"<p>\"\"</p> In\u00a0[\u00a0]: Copied! <pre>import leafmap\nfrom ipyleaflet import Map, SearchControl, Marker, AwesomeIcon\n</pre> import leafmap from ipyleaflet import Map, SearchControl, Marker, AwesomeIcon In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    center=[40, -100],\n    zoom=4,\n    draw_control=False,\n)\nm.add_basemap(\"Esri.WorldImagery\")\nurl = \"https://services.terrascope.be/wms/v2?\"\nm.add_wms_layer(\n    url=url,\n    layers=\"WORLDCOVER_2021_MAP\",\n    name=\"WORLDCOVER_2021_MAP\",\n    attribution=\"MRLC\",\n    format=\"image/png\",\n    shown=True,\n)\nm.add_legend(title=\"ESA World Cover 2021 Map\", builtin_legend=\"ESA_WorldCover\")\nsearch_url = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\"\nsearch_marker = Marker(\n    icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\")\n)\nm.add_search_control(url, zoom=10, marker=search_marker, position=\"topleft\")\nm.add_layer_control()\nm\n</pre> m = leafmap.Map(     center=[40, -100],     zoom=4,     draw_control=False, ) m.add_basemap(\"Esri.WorldImagery\") url = \"https://services.terrascope.be/wms/v2?\" m.add_wms_layer(     url=url,     layers=\"WORLDCOVER_2021_MAP\",     name=\"WORLDCOVER_2021_MAP\",     attribution=\"MRLC\",     format=\"image/png\",     shown=True, ) m.add_legend(title=\"ESA World Cover 2021 Map\", builtin_legend=\"ESA_WorldCover\") search_url = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\" search_marker = Marker(     icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\") ) m.add_search_control(url, zoom=10, marker=search_marker, position=\"topleft\") m.add_layer_control() m In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>import pandas as pd\nimport geopandas as gpd\n</pre> import pandas as pd import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>file_path = \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\"\n\ngdf = gpd.read_file(file_path)\ngdf[\"longitude\"] = gdf.geometry.x\ngdf[\"latitude\"] = gdf.geometry.y\n\nm2 = leafmap.Map(\n    center=[40, -100],\n    zoom=4,\n    draw_control=False,\n)\n\nm2.add_marker_cluster(\n    data=gdf, x=\"longitude\", y=\"latitude\", layer_name=\"Building Clusters\"\n)\n\nm2.add_circle_markers_from_xy(\n    file_path,\n    x=\"longitude\",\n    y=\"latitude\",\n    radius=5,\n    color=\"red\",\n    fill_color=\"yellow\",\n    fill_opacity=0.8,\n    name=\"WA Building Centroids\",\n)\nm2.add_layer_control()\nm2\n</pre> file_path = \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\"  gdf = gpd.read_file(file_path) gdf[\"longitude\"] = gdf.geometry.x gdf[\"latitude\"] = gdf.geometry.y  m2 = leafmap.Map(     center=[40, -100],     zoom=4,     draw_control=False, )  m2.add_marker_cluster(     data=gdf, x=\"longitude\", y=\"latitude\", layer_name=\"Building Clusters\" )  m2.add_circle_markers_from_xy(     file_path,     x=\"longitude\",     y=\"latitude\",     radius=5,     color=\"red\",     fill_color=\"yellow\",     fill_opacity=0.8,     name=\"WA Building Centroids\", ) m2.add_layer_control() m2 In\u00a0[\u00a0]: Copied! <pre>gdf.explore()\n</pre> gdf.explore() In\u00a0[\u00a0]: Copied! <pre>building_overture = gpd.read_file(\n    \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\"\n)\nbuilding_overture.explore()\n</pre> building_overture = gpd.read_file(     \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\" ) building_overture.explore() In\u00a0[\u00a0]: Copied! <pre>building_overture = gpd.read_file(\n    \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\"\n)\n\nm3 = leafmap.Map(\n    center=[40, -100],\n    zoom=4,\n    draw_control=False,\n)\nstyle = {\"color\": \"red\", \"weight\": 2}\nm3.add_gdf(\n    building_overture, style=style, layer_name=\"Las Vegas Buildings\", zoom_to_layer=True\n)\nm3\n</pre> building_overture = gpd.read_file(     \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\" )  m3 = leafmap.Map(     center=[40, -100],     zoom=4,     draw_control=False, ) style = {\"color\": \"red\", \"weight\": 2} m3.add_gdf(     building_overture, style=style, layer_name=\"Las Vegas Buildings\", zoom_to_layer=True ) m3 In\u00a0[\u00a0]: Copied! <pre>las_vegas = gpd.read_file(\n    \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\"\n)\n\nm4 = leafmap.Map(\n    center=[40, -100],\n    zoom=4,\n    draw_control=False,\n)\nstyle = {\"color\": \"red\", \"weight\": 2}\nm4.add_gdf(las_vegas, style=style, layer_name=\"Las Vegas Buildings\", zoom_to_layer=True)\nm4\n</pre> las_vegas = gpd.read_file(     \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\" )  m4 = leafmap.Map(     center=[40, -100],     zoom=4,     draw_control=False, ) style = {\"color\": \"red\", \"weight\": 2} m4.add_gdf(las_vegas, style=style, layer_name=\"Las Vegas Buildings\", zoom_to_layer=True) m4 In\u00a0[\u00a0]: Copied! <pre>cloropleth = (\n    \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\"\n)\ncloropleth.explore\n</pre> cloropleth = (     \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\" ) cloropleth.explore In\u00a0[\u00a0]: Copied! <pre>m5 = leafmap.Map(\n    center=[40, -100],\n    zoom=4,\n    draw_control=False,\n)\nm5.add_data(\n    cloropleth,\n    column=\"POP_EST\",\n    scheme=\"Quantiles\",\n    cmap=\"Blues\",\n    legend_title=\"Population\",\n)\n</pre> m5 = leafmap.Map(     center=[40, -100],     zoom=4,     draw_control=False, ) m5.add_data(     cloropleth,     column=\"POP_EST\",     scheme=\"Quantiles\",     cmap=\"Blues\",     legend_title=\"Population\", )"},{"location":"examples/lab9/#q1-and-q2","title":"Q1 and Q2\u00b6","text":""},{"location":"examples/lab9/#q3","title":"Q3\u00b6","text":""},{"location":"examples/lab9/#q4","title":"Q4\u00b6","text":""},{"location":"examples/map/","title":"Map","text":"<p>\"\"</p> In\u00a0[\u00a0]: Copied! <pre># !pip install skiba # uncomment if need to install package\nimport skiba.interactive as interactive\nimport skiba.data_process as sdp\nimport ipyleaflet as ipy\nimport ee\n\n# Initialize Earth Engine\nee.Authenticate()\nee.Initialize()\n</pre> # !pip install skiba # uncomment if need to install package import skiba.interactive as interactive import skiba.data_process as sdp import ipyleaflet as ipy import ee  # Initialize Earth Engine ee.Authenticate() ee.Initialize() In\u00a0[\u00a0]: Copied! <pre>import geemap\n\ngeemap.get_ee_token()\n</pre> import geemap  geemap.get_ee_token() In\u00a0[\u00a0]: Copied! <pre>m = sdp.data_process().vbox\nwidget_control = ipy.WidgetControl(widget=m, position=\"bottomleft\")\nmap = interactive.Map()\nmap.add_control(widget_control)\nmap\n</pre> m = sdp.data_process().vbox widget_control = ipy.WidgetControl(widget=m, position=\"bottomleft\") map = interactive.Map() map.add_control(widget_control) map In\u00a0[\u00a0]: Copied! <pre>m = sdp.data_process().vbox\nm\n</pre> m = sdp.data_process().vbox m In\u00a0[\u00a0]: Copied! <pre>map = interactive.Map()\nmapdata\n</pre> map = interactive.Map() mapdata"},{"location":"examples/map_demo/","title":"Map demo","text":"In\u00a0[\u00a0]: Copied! <pre>import skiba.ipyleafletcode as sm\n</pre> import skiba.ipyleafletcode as sm In\u00a0[\u00a0]: Copied! <pre>sm.Map\n</pre> sm.Map In\u00a0[\u00a0]: Copied! <pre>m = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)\nurl = \"https://data.fs.usda.gov/geodata/rastergateway/downloadMap.php?mapID=354508215&amp;mapType=tif\"\n# m.add_raster(\"HMA_DM_6H_v01_DEMe_1km.tif\")\nm.add_raster(url)\nm\n</pre> m = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True) url = \"https://data.fs.usda.gov/geodata/rastergateway/downloadMap.php?mapID=354508215&amp;mapType=tif\" # m.add_raster(\"HMA_DM_6H_v01_DEMe_1km.tif\") m.add_raster(url) m In\u00a0[\u00a0]: Copied! <pre>m2 = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)\nurl2 = \"https://media.giphy.com/media/NvNyuTD794sIIPntaw/giphy.gif\"\nm2.add_image(url2, bounds=[[25, 50], [40, 20]], opacity=0.5)\nm2\n</pre> m2 = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True) url2 = \"https://media.giphy.com/media/NvNyuTD794sIIPntaw/giphy.gif\" m2.add_image(url2, bounds=[[25, 50], [40, 20]], opacity=0.5) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)\nurl3 = \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\"\nm3.add_video(url3, bounds=[[13, -130], [32, -100]], opacity=1)\nm3\n</pre> m3 = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True) url3 = \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\" m3.add_video(url3, bounds=[[13, -130], [32, -100]], opacity=1) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = sm.Map(center=(38.491, -95.712), zoom=4, scroll_wheel_zoom=True)\nurl4 = \"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\"\nm4.add_wms_layer(url4, layers=\"nexrad-n0r-900913\")\nm4\n</pre> m4 = sm.Map(center=(38.491, -95.712), zoom=4, scroll_wheel_zoom=True) url4 = \"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\" m4.add_wms_layer(url4, layers=\"nexrad-n0r-900913\") m4 In\u00a0[\u00a0]: Copied! <pre>m4 = sm.Map(center=(38.491, -95.712), zoom=4, scroll_wheel_zoom=True)\nurl4 = \"https://imagery.nationalmap.gov/arcgis/services/USGSNAIPPlus/ImageServer/WMSServer?\"\nm4.add_wms_layer(url4, layers=\"USGSNAIPPlus\", format=\"image/png\", transparent=True)\nm4\n</pre> m4 = sm.Map(center=(38.491, -95.712), zoom=4, scroll_wheel_zoom=True) url4 = \"https://imagery.nationalmap.gov/arcgis/services/USGSNAIPPlus/ImageServer/WMSServer?\" m4.add_wms_layer(url4, layers=\"USGSNAIPPlus\", format=\"image/png\", transparent=True) m4"},{"location":"examples/map_happy/","title":"Map happy","text":"In\u00a0[\u00a0]: Copied! <pre>print(\"I like maps\")\n</pre> print(\"I like maps\") In\u00a0[\u00a0]: Copied! <pre>print(\"Cool, me too\")\n</pre> print(\"Cool, me too\")"},{"location":"examples/solara/","title":"Solara","text":"In\u00a0[\u00a0]: Copied! <pre>import solara\nimport skiba\n\n\nPage()\n</pre> import solara import skiba   Page()"},{"location":"paper/paper/","title":"Paper","text":"<p>authors:     - name: Tara Skiba         orcid: 0009-0002-5354-3319         equal-contrib: true         affiliation: 1     - name: Qiusheng Wu         orcid: 0000-0001-5437-4073         equal-contrib: false         affiliation: 2     - name: Tyler Gifford         orcid: 0000-0002-2547-3547         equal-contrib: false         affiliation: 1</p> <p>affiliations:     - name: University of Tennessee, School of Natural Resources, USA         index: 1     - name: University of Tennessee, Department of Geography, USA         index: 2</p> <p>date: 18 April 2025 bibliography: paper.bib</p>"},{"location":"paper/paper/#summary","title":"Summary","text":"<p><code>skiba</code> is a python package deployed on hugging face to allow natural resource professionals such as foresters or wildlife managers to access and retrieve data from Google Earth Engine. This purpose of this package is designed to extract values for a list of provided coordinate points with .</p>"},{"location":"paper/paper/#introduction","title":"Introduction","text":"<p>In recent decades, remote sensing has become an invaluable tool in a multitude of fields, due to the versatility of data collected and potential applications<code>[@chiBigDataRemote2016]</code>. Such information can be revolutionary in the field of forestry, particularly for inventory and research purposes where large-scale or intense monitoring is difficult or impossible to conduct. However, the uptake of remote sensing in forestry has been slow due to a multitude of reasons, as outlined in <code>[fassnachtRemoteSensingForestry2024a]</code>. In addition, several major issues need to be overcome before remote sensing can be fully integrated into standard forestry practices, such as determining forest type, identifying individual trees and species, particularly in mixed-species, uneven aged stands <code>[@burkhartForestMeasurements2019; @jeronimoApplyingLiDARIndividual2018a]</code>.</p> <p>Despite this, foresters and forest biometricians can still utilize publicly available remotely sensed data for information that is not standard in a traditional forest inventory, and forest biometricians can consider various untested environmental and climatological variables to help explain forest dynamics, such as predicting live aboveground carbon (pending publication). Remotely sensed data can still be difficult to access due to various technical barriers as hosting platforms, like Google Earth Engine (GEE), require a proficiency in programming and handling geospatial data retrieve the desired information.</p> <p>Various tools and packages currently exist to help users streamline this point-oriented acquisition process, such as GEE\u2019s built-in Code Editor. However, these tools still require programming skills and a free, easy-to-use, point-and-click interface that does not require any programming knowledge does not yet exist. Other geographical software programs can query this information, such as ArcGIS and QGIS, but these programs may require a license, and the user must still have a proficient understanding of geospatial analysis to use the software. Even within open source projects for python, querying GEE data can still be a multi-step process that requires various package installations and coding in order to handle the data. A simplified process does not yet exist to help streamline this data acquisition.</p> <p>This package was developed to complement the USDA Forest Service's Forest Inventory and Analysis's (FIA) long-term national inventory as a part of a project using climate and environmental data from GEE databases. The FIA's inventory has been used frequently by forest biometricians due to the large spatial scale and long temporal scale of this database that can help answer large-scale questions. Due to how time intensive traditional forest inventories are, one plot is taken for every 6,000 acres (<code>@bechtoldEnhancedForestInventory2015</code>). Due to the sampling intensity and structure of this inventory design, plots are treated as individual observations in studies. In some instances, smaller grouping levels, such as condition level groups as described in <code>@yangEstimatingMaximumStand2022</code> and <code>@jhaEvaluationRegressionMethods2023</code>, are treated as individual observations, but smaller grouping levels within the plot may be assumed to have shared characteristics. Examples are elevation, slope, or aspect, which, if measured, are only taken at plot center and not the subplot or any other sub-plot level grouping. Furthermore, only the plot center's coordinates are recorded in the FIA database. Therefore, to complement the FIA's national inventory and its standard use in forest modeling, this package was designed to operate from this plot-level perspective by extracting the values from a GEE dataset for a specified coordinate point (plot center). This approach is appropriate to query data for any grouping level equal to or smaller than the plot level.</p> <p>This project will be expanded to fit the needs of forest biometricians as they are presented, such as extracting the mean value for a given area and increasing the map's functionality. More geojson layers will be added as well, such as national forests and parks. Furthermore, as this project is hosted on GitHub, users who are comfortable with python can expand and contribute to this package's functionality for their purposes. While this package was developed with forest biometricians in mind, this package can be beneficial to other natural resource professionals who may also desire to utilize the vast range of data available as desired.</p>"},{"location":"paper/paper/#skiba-audience","title":"skiba Audience","text":"<p><code>skiba</code> is intended for natural resource professionals who would like to extract Google Earth Engine data for given coordinates, but the use of this package can be useful in other disciplines. This package removes the technological barriers that limit the package\u2019s intended users from being able to utilize remotely sensed data. Users can access the base version of this package through huggingface (\u2026TBD), and users can modify and build upon this package through the package\u2019s GitHub and PyPI repositories. By design, this package is fairly rudimentary, with the goal of expanding the functions of this package to meet the needs of natural resource professionals accordingly. Two additional functions are currently being developed: a polygon buffering tool that will allow users to preserve any confidential coordinates they have and function that will extract temporal data, such as daily or monthly averages, for temporal analyses.</p> <p>This package has been used in existing research projects to query data and will be presented at various local and national conferences to promote its use to a broader range of users, as well as to the USFS Southern Research Station's FIA group in Knoxville, TN as an alternative to outsourcing their remote sensing needs to another office.</p>"},{"location":"paper/paper/#skiba-functionality","title":"skiba Functionality","text":"<p>The <code>skiba</code> package is built upon <code>@ipyleaflet</code> and <code>@geemap</code>, while also utilizing <code>@pandas</code> and <code>@geopandas</code> for data handling and <code>@ee</code> for source data. <code>skiba</code> is broken into two key modules: -   <code>map_details</code>: module for displaying an interactive map with uploaded coordinates plotted. Users may customize the map as allowed. This module uses <code>@ipyleaflet</code>, <code>@ipywidgets</code>, and <code>@geemap</code>. A walkthrough of this map feature can be found in <code>map_details_demo.ipynb</code> -   <code>data_process</code>: module for processing GEE data and returning the desired information for the user-provided coordinates. This module utilizes <code>@geemap</code>, <code>@pandas</code>, <code>@geopandas</code>, and <code>@ipywidgets</code>. A full demonstration of this module can be found in <code>data_process_demo.ipynb</code>.</p>"},{"location":"paper/paper/#skiba-user-guide","title":"skiba User Guide","text":"<ul> <li>Step 1:   The User uploads a csv or xlsx file that must at least the following three columns: a plot identifier (e.g. plot #), latitude (in dd.), longitude (in dd.).</li> <li>Example csv file format:     <pre><code>\"plot_ID\",\"LAT\",\"LON\"\n\"37_39_63\",35.138399,-84.180002\n</code></pre> Note: latitude and longitude column names must match example format</li> <li>Step 2:   A map will appear with provided coordinates plotted.      Example of <code>map_details</code> module with sample dataset.</li> <li>Step 3:   User selects a Google Earth Engine dataset from the dropdown.</li> <li>Step 3.b (Optional):   User selects desired time frame.</li> <li>Step 4:   Package returns a csv file with point values from all bands of provided coordinates within selected GEE dataset. The csv file will be automatically saved in the user's local <code>~/Downloads</code> folder.</li> <li>Note: the full website is still pending, but temporary demos can be found as stated in the functionality section. This package may be temporarily used through the package's Colab pages until the official website is built.</li> </ul>"},{"location":"paper/paper/#acknowledgements","title":"Acknowledgements","text":"<p>The author would like to thank the developers of geemap, ipyleafet, and ipywidgets, which were heavily utilized to efficiently create a map and query the desired data. The author would also like to thank the the USDA's U.S. Forest Service Forest Inventory and Analysis program for their financial support.</p>"},{"location":"paper/paper/#references","title":"References","text":""}]}