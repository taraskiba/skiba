{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to skiba","text":"<p>A python package for a foresters to query Google Earth Engine data</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://taraskiba.github.io/skiba</li> <li>Streamlit App: https://gskiba.streamlit.app/</li> </ul> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Access and retrieve pixel values from Google Earth Engine Images or ImageCollections and a desired time-period for a .CSV provided coordinates.<ul> <li>Results can be exported averaged over matching plot IDs or individual points.</li> </ul> </li> <li>Buffer sensitive coordinates:<ul> <li>Buffer to a singular point within a specified radius.</li> <li>Buffer to n points within a specified radius.</li> </ul> </li> <li>Create a map with provided coordinates and built-in basemaps and geojson overlays.</li> <li>Please understand the limitations of Google's confidentiality policy before use.</li> </ul>"},{"location":"aggregated_point_extraction/","title":"aggregated_point_extraction module","text":""},{"location":"aggregated_point_extraction/#skiba.aggregated_point_extraction.AggregatedPointExtraction","title":"<code> AggregatedPointExtraction        </code>","text":"Source code in <code>skiba/aggregated_point_extraction.py</code> <pre><code>class AggregatedPointExtraction:\n    def __init__(self):\n        # File Upload\n        self.file_upload = widgets.FileUpload(\n            accept=\".csv, .txt\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n            multiple=False,  # True to accept multiple files upload else False\n        )\n        # Dropdown\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = AggregatedPointExtraction.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        self.dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n        self.start_date = widgets.DatePicker(description=\"Start Date\", disabled=False)\n        self.end_date = widgets.DatePicker(description=\"End Date\", disabled=False)\n        self.run_button = widgets.Button(\n            description=\"Run Query\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            icon=\"rotate right\",  # (FontAwesome names without the `fa-` prefix)\n        )\n        self.output = widgets.Output()\n        self.run_button.on_click(self.on_button_clicked)\n        self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n        self.hbox = widgets.HBox(\n            [\n                self.file_upload,\n                self.dropdown,\n                self.start_date,\n                self.end_date,\n                self.run_button,\n            ]\n        )\n        self.vbox = widgets.VBox([self.hbox, self.output])\n\n    def on_dropdown_change(self, change):\n        if change[\"new\"]:\n            with self.output:\n                self.output.clear_output()\n                catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n                data = AggregatedPointExtraction.fetch_geojson(catalog)\n                data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n                change_value = str(change[\"new\"])\n                url = data_dict.get(change_value)\n                print(f\"Selected dataset: {change['new']}\")\n                print(f\"URL: {url}\")\n\n    def on_button_clicked(self, b):\n        with self.output:\n            self.output.clear_output()\n            print(\n                f\"You entered: {self.dropdown.value}. CSV file will be saved to Downloads folder under this name.\"\n            )\n            import io\n\n            if self.file_upload.value:\n                # For the first file (if multiple=False)\n                file_info = self.file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()  # file content as bytes\n                points = pd.read_csv(io.BytesIO(content_bytes))\n                lat_cols = [\"lat\", \"latitude\", \"y\", \"LAT\", \"Latitude\", \"Lat\", \"Y\"]\n                lon_cols = [\n                    \"lon\",\n                    \"long\",\n                    \"longitude\",\n                    \"x\",\n                    \"LON\",\n                    \"Longitude\",\n                    \"Long\",\n                    \"X\",\n                ]\n                id_cols = [\"id\", \"ID\", \"plot_ID\", \"plot_id\", \"plotID\", \"plotId\"]\n\n                def find_column(possible_names, columns):\n                    for name in possible_names:\n                        if name in columns:\n                            return name\n                    # fallback: check case-insensitive match\n                    lower_columns = {c.lower(): c for c in columns}\n                    for name in possible_names:\n                        if name.lower() in lower_columns:\n                            return lower_columns[name.lower()]\n                    raise ValueError(f\"No matching column found for {possible_names}\")\n\n                lat_col = find_column(lat_cols, points.columns)\n                lon_col = find_column(lon_cols, points.columns)\n                id_col = find_column(id_cols, points.columns)\n                points = points.rename(\n                    columns={lat_col: \"LAT\", lon_col: \"LON\", id_col: \"plot_ID\"}\n                )\n            else:\n                print(\"Please upload a CSV file.\")\n            geedata = self.dropdown.value\n            start_date = self.start_date.value\n            end_date = self.end_date.value\n            self.get_coordinate_data(\n                data=points, geedata=geedata, start_date=start_date, end_date=end_date\n            )\n\n    def get_coordinate_data(self, data, geedata, start_date, end_date, **kwargs):\n        \"\"\"\n        Pull data from provided coordinates from GEE.\n\n        Args:\n            data (str): The data to get the coordinate data from.\n\n        Returns:\n            data (str): CSV file contained GEE data.\n        \"\"\"\n\n        # Load data with safety checks\n        if isinstance(data, str):\n            coordinates = pd.read_csv(data)\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        elif isinstance(data, pd.DataFrame):\n            coordinates = data\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        else:\n            gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n        geojson = gdf.__geo_interface__\n        fc = gm.geojson_to_ee(geojson)\n        # Load the GEE dataset as an image\n        geeimage = AggregatedPointExtraction.load_gee_as_image(\n            geedata, start_date, end_date\n        )\n        name = f\"{geedata}\"\n        file_name = name.replace(\"/\", \"_\")\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        output_file = f\"{file_name}.csv\"\n        out_path = os.path.join(out_dir, output_file)\n        # Retrieve data from the image using sampleRegions\n        sampled_data = gm.extract_values_to_points(fc, geeimage, scale=None)\n        sampled_df = gm.ee_to_df(sampled_data)\n        filtered_df = sampled_df.drop([\"LAT\", \"LON\", \"Unnamed: 0\"], axis=1)\n        print(\"Pre-aggregation data preview:\")\n        print(filtered_df.head())\n        aggregated_df = filtered_df.groupby(\"plot_ID\").mean()\n        aggregated_df.to_csv(out_path)\n        return aggregated_df\n\n    def fetch_geojson(url):\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raises an exception for HTTP errors\n            geojson_data = response.json()  # Parse the JSON response\n            return geojson_data\n        except requests.exceptions.HTTPError as http_err:\n            print(f\"HTTP error occurred: {http_err}\")\n        except requests.exceptions.ConnectionError as conn_err:\n            print(f\"Error connecting to the server: {conn_err}\")\n        except Exception as err:\n            print(f\"An error occurred: {err}\")\n        return None\n\n    def create_dropdown():\n        \"\"\"\n        Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n        Args:\n            url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n        Returns:\n            ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n        \"\"\"\n\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = AggregatedPointExtraction.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n        return dropdown\n\n    def add_date_picker():\n        date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n        return date_picker\n\n    def load_gee_as_image(dataset_id, start_date, end_date, **kwargs):\n        \"\"\"\n        Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n        Optionally filters by start and end date if applicable.\n\n        Parameters:\n            dataset_id (str): The Earth Engine dataset ID.\n            start_date (str): Optional start date in 'YYYY-MM-DD' format.\n            end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n        Returns:\n            ee.Image: The resulting image.\n        \"\"\"\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        response = requests.get(url)\n        response.raise_for_status()  # Raises an exception for HTTP errors\n        geojson_data = response.json()\n        data_type = [item[\"type\"] for item in geojson_data if item[\"id\"] == dataset_id]\n        data_str = \" \".join(data_type)\n        start_date = str(start_date)\n        end_date = str(end_date)\n        # Try loading as Image\n        if data_str == \"image\":\n            img = ee.Image(dataset_id)\n            # If .getInfo() doesn't throw, it's an Image\n            img.getInfo()\n            return img\n        elif data_str == \"image_collection\":\n            col = ee.ImageCollection(dataset_id)\n            # If date filters are provided, apply them\n            if start_date is None and end_date is None:\n                col = col.filterDate(start_date, end_date)\n            else:\n                pass\n            # Reduce to a single image (e.g., median composite)\n            img = col.median()\n            return img\n        # Try loading as FeatureCollection (convert to raster)\n        else:\n            # fc_temp = ee.FeatureCollection(dataset_id)\n            # if start_date is None and end_date is None:\n            #         fc_temp = fc_temp.filterDate(start_date, end_date)\n            # # Convert to raster: burn a value of 1 into a new image\n            # img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.median())\n            # img.getInfo()\n            # return img\n            # or print(f\"Dataset must be either an Image or Image Collection\")\n            raise ValueError(\"Dataset ID is not a valid Image or ImageCollection.\")\n</code></pre>"},{"location":"aggregated_point_extraction/#skiba.aggregated_point_extraction.AggregatedPointExtraction.create_dropdown","title":"<code>create_dropdown()</code>","text":"<p>Creates an ipywidgets dropdown menu from a GeoJSON catalog.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the GeoJSON catalog. Defaults to the Opengeos catalog.</p> required <p>Returns:</p> Type Description <code>ipywidgets.Dropdown</code> <p>A dropdown widget with the names from the catalog.</p> Source code in <code>skiba/aggregated_point_extraction.py</code> <pre><code>def create_dropdown():\n    \"\"\"\n    Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n    Args:\n        url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n    Returns:\n        ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n    \"\"\"\n\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    data = AggregatedPointExtraction.fetch_geojson(url)\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n    dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n    return dropdown\n</code></pre>"},{"location":"aggregated_point_extraction/#skiba.aggregated_point_extraction.AggregatedPointExtraction.get_coordinate_data","title":"<code>get_coordinate_data(self, data, geedata, start_date, end_date, **kwargs)</code>","text":"<p>Pull data from provided coordinates from GEE.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to get the coordinate data from.</p> required <p>Returns:</p> Type Description <code>data (str)</code> <p>CSV file contained GEE data.</p> Source code in <code>skiba/aggregated_point_extraction.py</code> <pre><code>def get_coordinate_data(self, data, geedata, start_date, end_date, **kwargs):\n    \"\"\"\n    Pull data from provided coordinates from GEE.\n\n    Args:\n        data (str): The data to get the coordinate data from.\n\n    Returns:\n        data (str): CSV file contained GEE data.\n    \"\"\"\n\n    # Load data with safety checks\n    if isinstance(data, str):\n        coordinates = pd.read_csv(data)\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    elif isinstance(data, pd.DataFrame):\n        coordinates = data\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    else:\n        gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n    geojson = gdf.__geo_interface__\n    fc = gm.geojson_to_ee(geojson)\n    # Load the GEE dataset as an image\n    geeimage = AggregatedPointExtraction.load_gee_as_image(\n        geedata, start_date, end_date\n    )\n    name = f\"{geedata}\"\n    file_name = name.replace(\"/\", \"_\")\n    out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n    output_file = f\"{file_name}.csv\"\n    out_path = os.path.join(out_dir, output_file)\n    # Retrieve data from the image using sampleRegions\n    sampled_data = gm.extract_values_to_points(fc, geeimage, scale=None)\n    sampled_df = gm.ee_to_df(sampled_data)\n    filtered_df = sampled_df.drop([\"LAT\", \"LON\", \"Unnamed: 0\"], axis=1)\n    print(\"Pre-aggregation data preview:\")\n    print(filtered_df.head())\n    aggregated_df = filtered_df.groupby(\"plot_ID\").mean()\n    aggregated_df.to_csv(out_path)\n    return aggregated_df\n</code></pre>"},{"location":"aggregated_point_extraction/#skiba.aggregated_point_extraction.AggregatedPointExtraction.load_gee_as_image","title":"<code>load_gee_as_image(dataset_id, start_date, end_date, **kwargs)</code>","text":"<p>Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image. Optionally filters by start and end date if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The Earth Engine dataset ID.</p> required <code>start_date</code> <code>str</code> <p>Optional start date in 'YYYY-MM-DD' format.</p> required <code>end_date</code> <code>str</code> <p>Optional end date in 'YYYY-MM-DD' format.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The resulting image.</p> Source code in <code>skiba/aggregated_point_extraction.py</code> <pre><code>def load_gee_as_image(dataset_id, start_date, end_date, **kwargs):\n    \"\"\"\n    Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n    Optionally filters by start and end date if applicable.\n\n    Parameters:\n        dataset_id (str): The Earth Engine dataset ID.\n        start_date (str): Optional start date in 'YYYY-MM-DD' format.\n        end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        ee.Image: The resulting image.\n    \"\"\"\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    response = requests.get(url)\n    response.raise_for_status()  # Raises an exception for HTTP errors\n    geojson_data = response.json()\n    data_type = [item[\"type\"] for item in geojson_data if item[\"id\"] == dataset_id]\n    data_str = \" \".join(data_type)\n    start_date = str(start_date)\n    end_date = str(end_date)\n    # Try loading as Image\n    if data_str == \"image\":\n        img = ee.Image(dataset_id)\n        # If .getInfo() doesn't throw, it's an Image\n        img.getInfo()\n        return img\n    elif data_str == \"image_collection\":\n        col = ee.ImageCollection(dataset_id)\n        # If date filters are provided, apply them\n        if start_date is None and end_date is None:\n            col = col.filterDate(start_date, end_date)\n        else:\n            pass\n        # Reduce to a single image (e.g., median composite)\n        img = col.median()\n        return img\n    # Try loading as FeatureCollection (convert to raster)\n    else:\n        # fc_temp = ee.FeatureCollection(dataset_id)\n        # if start_date is None and end_date is None:\n        #         fc_temp = fc_temp.filterDate(start_date, end_date)\n        # # Convert to raster: burn a value of 1 into a new image\n        # img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.median())\n        # img.getInfo()\n        # return img\n        # or print(f\"Dataset must be either an Image or Image Collection\")\n        raise ValueError(\"Dataset ID is not a valid Image or ImageCollection.\")\n</code></pre>"},{"location":"buffer_and_sample/","title":"buffer_and_sample module","text":""},{"location":"buffer_and_sample/#skiba.buffer_and_sample.Buffer","title":"<code> Buffer        </code>","text":"Source code in <code>skiba/buffer_and_sample.py</code> <pre><code>class Buffer:\n    def __init__(self):\n        \"\"\"\n        Initializes the buffer_coordinates class and sets up the GUI components.\n        Part 1 of buffered coordinates approach which creates circles around points.\n        (Part 2 is in buffer_method.py)\n        \"\"\"\n        # File Upload\n        self.file_upload = widgets.FileUpload(\n            accept=\".csv, .txt\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n            multiple=False,  # True to accept multiple files upload else False\n        )\n\n        # Dropdown\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = self.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        self.dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"OPTIONAL:\",\n            disabled=False,\n        )\n        self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n        self.buffer_radius = widgets.FloatText(\n            value=100,\n            description=\"Buffer radius (ft):\",\n            disabled=False,\n            display=\"flex\",\n            flex_flow=\"column\",\n            align_items=\"stretch\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        self.sample_button = widgets.IntText(\n            value=10,\n            description=\"Sampling number (int):\",\n            disabled=False,\n            display=\"flex\",\n            flex_flow=\"column\",\n            align_items=\"stretch\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        self.run_button = widgets.Button(\n            description=\"Run Query\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            icon=\"rotate right\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        self.output = widgets.Output()\n\n        self.run_button.on_click(self.on_button_clicked)\n\n        self.hbox = widgets.HBox(\n            [\n                self.file_upload,\n                self.buffer_radius,\n                self.sample_button,\n                self.run_button,\n            ]\n        )\n\n        self.vbox = widgets.VBox([self.hbox, self.output])\n\n    def on_button_clicked(self, b):\n        \"\"\"\n        Callback function to handle button click events.\"\"\"\n        with self.output:\n            self.output.clear_output()\n            print(\n                f\"GeoJSON file will be saved to Downloads folder under this name:{self.buffer_radius.value}ft.csv\"\n            )\n\n            import io\n\n            if self.file_upload.value:\n                # For the first file (if multiple=False)\n                file_info = self.file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()  # file content as bytes\n                points = pd.read_csv(io.BytesIO(content_bytes))\n                lat_cols = [\"lat\", \"latitude\", \"y\", \"LAT\", \"Latitude\", \"Lat\", \"Y\"]\n                lon_cols = [\n                    \"lon\",\n                    \"long\",\n                    \"longitude\",\n                    \"x\",\n                    \"LON\",\n                    \"Longitude\",\n                    \"Long\",\n                    \"X\",\n                ]\n                id_cols = [\"id\", \"ID\", \"plot_ID\", \"plot_id\", \"plotID\", \"plotId\"]\n\n                def find_column(possible_names, columns):\n                    for name in possible_names:\n                        if name in columns:\n                            return name\n                    # fallback: check case-insensitive match\n                    lower_columns = {c.lower(): c for c in columns}\n                    for name in possible_names:\n                        if name.lower() in lower_columns:\n                            return lower_columns[name.lower()]\n                    raise ValueError(f\"No matching column found for {possible_names}\")\n\n                lat_col = find_column(lat_cols, points.columns)\n                lon_col = find_column(lon_cols, points.columns)\n                id_col = find_column(id_cols, points.columns)\n                points = points.rename(\n                    columns={lat_col: \"LAT\", lon_col: \"LON\", id_col: \"plot_ID\"}\n                )\n            else:\n                print(\"Please upload a CSV file.\")\n\n            radius_ft = self.buffer_radius.value\n            no_samp = self.sample_button.value\n\n            out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n            output_file = f\"{radius_ft}ft.csv\"\n            out_path = os.path.join(out_dir, output_file)\n\n            self.obfuscate_points(\n                data=points,\n                radius_feet=radius_ft,\n                no_samp=no_samp,\n                plot_id_col=\"plot_ID\",\n                output_file=out_path,\n            )\n            print(f\"Buffered coordinates saved to {out_path}\")\n\n    def on_dropdown_change(self, change):\n        \"\"\"\n        Callback function to handle dropdown value changes.\n        \"\"\"\n        if change[\"new\"]:\n            with self.output:\n                self.output.clear_output()\n                catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n                data = self.fetch_geojson(catalog)\n                data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n                change_value = str(change[\"new\"])\n                url = data_dict.get(change_value)\n                print(f\"Selected dataset: {change['new']}\")\n                print(f\"URL: {url}\")\n\n    def create_obfuscated_points(self, point, radius_feet, no_samp, crs=\"EPSG:4326\"):\n        \"\"\"\n        Create a circle polygon (as a shapely geometry) with the given radius in feet,\n        where the provided point is randomly located inside the circle (not at the center).\n        \"\"\"\n        # Convert radius from feet to meters\n        radius_m = radius_feet * 0.3048\n\n        # Project to local UTM for accurate distance calculations\n        utm_crs = f\"EPSG:326{int((point.x + 180) // 6) + 1}\"\n        transformer_to_utm = Transformer.from_crs(crs, utm_crs, always_xy=True)\n        transformer_to_latlon = Transformer.from_crs(utm_crs, crs, always_xy=True)\n        x, y = transformer_to_utm.transform(point.x, point.y)\n\n        # Randomize the point's location within the circle\n        points = []\n        for no in range(no_samp):\n            # Randomize the point's location within the circle\n            angle = np.random.uniform(0, 2 * np.pi)\n            distance = np.random.uniform(0, radius_m)\n            # Calculate center of the circle so that the point is inside the circle but not at the center\n            center_x = x - distance * np.cos(angle)\n            center_y = y - distance * np.sin(angle)\n            center = Point(center_x, center_y)\n            center_latlon = shapely.ops.transform(\n                lambda x, y: transformer_to_latlon.transform(x, y), center\n            )\n            points.append(center_latlon)\n        return points\n\n    def obfuscate_points(self, data, radius_feet, no_samp, plot_id_col, output_file):\n        \"\"\"\n        Obfuscate points within a radius and save as csv.\n\n        Args:\n            data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n            radius_feet (float): Radius of the circle in feet.\n            plot_id_col (str): Column name for plot IDs.\n            output_file (str): Path to save the output GeoJSON file.\n        \"\"\"\n        if isinstance(data, str):\n            coordinates = pd.read_csv(data)\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        elif isinstance(data, pd.DataFrame):\n            coordinates = data\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        else:\n            gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n        centers = []\n\n        for idx, row in gdf.iterrows():\n            point = row[\"geometry\"]\n            center = self.create_obfuscated_points(\n                point, radius_feet, no_samp, crs=gdf.crs\n            )\n            for pt in center:\n                centers.append({\"plot_ID\": row[plot_id_col], \"lat\": pt.y, \"lon\": pt.x})\n            # Create new GeoDataFrame\n        df = pd.DataFrame(centers)\n        # point_df = pd.DataFrame(gdf_circles)\n        point_csv = df.to_csv()\n        with open(output_file, \"w\", newline=\"\") as f:\n            f.write(point_csv)\n        print(f\"CSV saved to {output_file}\")\n        return point_csv\n\n    def fetch_geojson(self, url):\n        \"\"\"\n        Fetch GeoJSON data from a given URL.\n\n        Args:\n            url (str): URL to fetch the GeoJSON data from.\n        \"\"\"\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raises an exception for HTTP errors\n            geojson_data = response.json()  # Parse the JSON response\n            return geojson_data\n        except requests.exceptions.HTTPError as http_err:\n            print(f\"HTTP error occurred: {http_err}\")\n        except requests.exceptions.ConnectionError as conn_err:\n            print(f\"Error connecting to the server: {conn_err}\")\n        except Exception as err:\n            print(f\"An error occurred: {err}\")\n        return None\n</code></pre>"},{"location":"buffer_and_sample/#skiba.buffer_and_sample.Buffer.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initializes the buffer_coordinates class and sets up the GUI components. Part 1 of buffered coordinates approach which creates circles around points. (Part 2 is in buffer_method.py)</p> Source code in <code>skiba/buffer_and_sample.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the buffer_coordinates class and sets up the GUI components.\n    Part 1 of buffered coordinates approach which creates circles around points.\n    (Part 2 is in buffer_method.py)\n    \"\"\"\n    # File Upload\n    self.file_upload = widgets.FileUpload(\n        accept=\".csv, .txt\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n        multiple=False,  # True to accept multiple files upload else False\n    )\n\n    # Dropdown\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    data = self.fetch_geojson(url)\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n    self.dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"OPTIONAL:\",\n        disabled=False,\n    )\n    self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n    self.buffer_radius = widgets.FloatText(\n        value=100,\n        description=\"Buffer radius (ft):\",\n        disabled=False,\n        display=\"flex\",\n        flex_flow=\"column\",\n        align_items=\"stretch\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    self.sample_button = widgets.IntText(\n        value=10,\n        description=\"Sampling number (int):\",\n        disabled=False,\n        display=\"flex\",\n        flex_flow=\"column\",\n        align_items=\"stretch\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    self.run_button = widgets.Button(\n        description=\"Run Query\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        icon=\"rotate right\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    self.output = widgets.Output()\n\n    self.run_button.on_click(self.on_button_clicked)\n\n    self.hbox = widgets.HBox(\n        [\n            self.file_upload,\n            self.buffer_radius,\n            self.sample_button,\n            self.run_button,\n        ]\n    )\n\n    self.vbox = widgets.VBox([self.hbox, self.output])\n</code></pre>"},{"location":"buffer_and_sample/#skiba.buffer_and_sample.Buffer.create_obfuscated_points","title":"<code>create_obfuscated_points(self, point, radius_feet, no_samp, crs='EPSG:4326')</code>","text":"<p>Create a circle polygon (as a shapely geometry) with the given radius in feet, where the provided point is randomly located inside the circle (not at the center).</p> Source code in <code>skiba/buffer_and_sample.py</code> <pre><code>def create_obfuscated_points(self, point, radius_feet, no_samp, crs=\"EPSG:4326\"):\n    \"\"\"\n    Create a circle polygon (as a shapely geometry) with the given radius in feet,\n    where the provided point is randomly located inside the circle (not at the center).\n    \"\"\"\n    # Convert radius from feet to meters\n    radius_m = radius_feet * 0.3048\n\n    # Project to local UTM for accurate distance calculations\n    utm_crs = f\"EPSG:326{int((point.x + 180) // 6) + 1}\"\n    transformer_to_utm = Transformer.from_crs(crs, utm_crs, always_xy=True)\n    transformer_to_latlon = Transformer.from_crs(utm_crs, crs, always_xy=True)\n    x, y = transformer_to_utm.transform(point.x, point.y)\n\n    # Randomize the point's location within the circle\n    points = []\n    for no in range(no_samp):\n        # Randomize the point's location within the circle\n        angle = np.random.uniform(0, 2 * np.pi)\n        distance = np.random.uniform(0, radius_m)\n        # Calculate center of the circle so that the point is inside the circle but not at the center\n        center_x = x - distance * np.cos(angle)\n        center_y = y - distance * np.sin(angle)\n        center = Point(center_x, center_y)\n        center_latlon = shapely.ops.transform(\n            lambda x, y: transformer_to_latlon.transform(x, y), center\n        )\n        points.append(center_latlon)\n    return points\n</code></pre>"},{"location":"buffer_and_sample/#skiba.buffer_and_sample.Buffer.fetch_geojson","title":"<code>fetch_geojson(self, url)</code>","text":"<p>Fetch GeoJSON data from a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch the GeoJSON data from.</p> required Source code in <code>skiba/buffer_and_sample.py</code> <pre><code>def fetch_geojson(self, url):\n    \"\"\"\n    Fetch GeoJSON data from a given URL.\n\n    Args:\n        url (str): URL to fetch the GeoJSON data from.\n    \"\"\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # Raises an exception for HTTP errors\n        geojson_data = response.json()  # Parse the JSON response\n        return geojson_data\n    except requests.exceptions.HTTPError as http_err:\n        print(f\"HTTP error occurred: {http_err}\")\n    except requests.exceptions.ConnectionError as conn_err:\n        print(f\"Error connecting to the server: {conn_err}\")\n    except Exception as err:\n        print(f\"An error occurred: {err}\")\n    return None\n</code></pre>"},{"location":"buffer_and_sample/#skiba.buffer_and_sample.Buffer.obfuscate_points","title":"<code>obfuscate_points(self, data, radius_feet, no_samp, plot_id_col, output_file)</code>","text":"<p>Obfuscate points within a radius and save as csv.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, pd.DataFrame, gpd.GeoDataFrame</code> <p>Input data (GeoJSON, DataFrame, or GeoDataFrame).</p> required <code>radius_feet</code> <code>float</code> <p>Radius of the circle in feet.</p> required <code>plot_id_col</code> <code>str</code> <p>Column name for plot IDs.</p> required <code>output_file</code> <code>str</code> <p>Path to save the output GeoJSON file.</p> required Source code in <code>skiba/buffer_and_sample.py</code> <pre><code>def obfuscate_points(self, data, radius_feet, no_samp, plot_id_col, output_file):\n    \"\"\"\n    Obfuscate points within a radius and save as csv.\n\n    Args:\n        data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n        radius_feet (float): Radius of the circle in feet.\n        plot_id_col (str): Column name for plot IDs.\n        output_file (str): Path to save the output GeoJSON file.\n    \"\"\"\n    if isinstance(data, str):\n        coordinates = pd.read_csv(data)\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    elif isinstance(data, pd.DataFrame):\n        coordinates = data\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    else:\n        gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n    centers = []\n\n    for idx, row in gdf.iterrows():\n        point = row[\"geometry\"]\n        center = self.create_obfuscated_points(\n            point, radius_feet, no_samp, crs=gdf.crs\n        )\n        for pt in center:\n            centers.append({\"plot_ID\": row[plot_id_col], \"lat\": pt.y, \"lon\": pt.x})\n        # Create new GeoDataFrame\n    df = pd.DataFrame(centers)\n    # point_df = pd.DataFrame(gdf_circles)\n    point_csv = df.to_csv()\n    with open(output_file, \"w\", newline=\"\") as f:\n        f.write(point_csv)\n    print(f\"CSV saved to {output_file}\")\n    return point_csv\n</code></pre>"},{"location":"buffer_and_sample/#skiba.buffer_and_sample.Buffer.on_button_clicked","title":"<code>on_button_clicked(self, b)</code>","text":"<p>Callback function to handle button click events.</p> Source code in <code>skiba/buffer_and_sample.py</code> <pre><code>def on_button_clicked(self, b):\n    \"\"\"\n    Callback function to handle button click events.\"\"\"\n    with self.output:\n        self.output.clear_output()\n        print(\n            f\"GeoJSON file will be saved to Downloads folder under this name:{self.buffer_radius.value}ft.csv\"\n        )\n\n        import io\n\n        if self.file_upload.value:\n            # For the first file (if multiple=False)\n            file_info = self.file_upload.value[0]\n            content_bytes = file_info[\"content\"].tobytes()  # file content as bytes\n            points = pd.read_csv(io.BytesIO(content_bytes))\n            lat_cols = [\"lat\", \"latitude\", \"y\", \"LAT\", \"Latitude\", \"Lat\", \"Y\"]\n            lon_cols = [\n                \"lon\",\n                \"long\",\n                \"longitude\",\n                \"x\",\n                \"LON\",\n                \"Longitude\",\n                \"Long\",\n                \"X\",\n            ]\n            id_cols = [\"id\", \"ID\", \"plot_ID\", \"plot_id\", \"plotID\", \"plotId\"]\n\n            def find_column(possible_names, columns):\n                for name in possible_names:\n                    if name in columns:\n                        return name\n                # fallback: check case-insensitive match\n                lower_columns = {c.lower(): c for c in columns}\n                for name in possible_names:\n                    if name.lower() in lower_columns:\n                        return lower_columns[name.lower()]\n                raise ValueError(f\"No matching column found for {possible_names}\")\n\n            lat_col = find_column(lat_cols, points.columns)\n            lon_col = find_column(lon_cols, points.columns)\n            id_col = find_column(id_cols, points.columns)\n            points = points.rename(\n                columns={lat_col: \"LAT\", lon_col: \"LON\", id_col: \"plot_ID\"}\n            )\n        else:\n            print(\"Please upload a CSV file.\")\n\n        radius_ft = self.buffer_radius.value\n        no_samp = self.sample_button.value\n\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        output_file = f\"{radius_ft}ft.csv\"\n        out_path = os.path.join(out_dir, output_file)\n\n        self.obfuscate_points(\n            data=points,\n            radius_feet=radius_ft,\n            no_samp=no_samp,\n            plot_id_col=\"plot_ID\",\n            output_file=out_path,\n        )\n        print(f\"Buffered coordinates saved to {out_path}\")\n</code></pre>"},{"location":"buffer_and_sample/#skiba.buffer_and_sample.Buffer.on_dropdown_change","title":"<code>on_dropdown_change(self, change)</code>","text":"<p>Callback function to handle dropdown value changes.</p> Source code in <code>skiba/buffer_and_sample.py</code> <pre><code>def on_dropdown_change(self, change):\n    \"\"\"\n    Callback function to handle dropdown value changes.\n    \"\"\"\n    if change[\"new\"]:\n        with self.output:\n            self.output.clear_output()\n            catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n            data = self.fetch_geojson(catalog)\n            data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n            change_value = str(change[\"new\"])\n            url = data_dict.get(change_value)\n            print(f\"Selected dataset: {change['new']}\")\n            print(f\"URL: {url}\")\n</code></pre>"},{"location":"buffer_coordinates/","title":"buffer_coordinates module","text":""},{"location":"buffer_coordinates/#skiba.buffer_coordinates.BufferCoordinates","title":"<code> BufferCoordinates        </code>","text":"Source code in <code>skiba/buffer_coordinates.py</code> <pre><code>class BufferCoordinates:\n    def __init__(self):\n        \"\"\"\n        Initializes the buffer_coordinates class and sets up the GUI components.\n        Part 1 of buffered coordinates approach which creates circles around points.\n        (Part 2 is in buffer_method.py)\n        \"\"\"\n        # File Upload\n        self.file_upload = widgets.FileUpload(\n            accept=\".csv, .txt\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n            multiple=False,  # True to accept multiple files upload else False\n        )\n\n        # Dropdown\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = self.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        self.dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n        self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n        self.buffer_radius = widgets.FloatText(\n            value=10,\n            description=\"Buffer radius (ft):\",\n            disabled=False,\n            display=\"flex\",\n            flex_flow=\"column\",\n            align_items=\"stretch\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        self.run_button = widgets.Button(\n            description=\"Run Query\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            icon=\"rotate right\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        self.output = widgets.Output()\n\n        self.run_button.on_click(self.on_button_clicked)\n\n        self.hbox = widgets.HBox(\n            [self.file_upload, self.dropdown, self.buffer_radius, self.run_button]\n        )\n\n        self.vbox = widgets.VBox([self.hbox, self.output])\n\n    def on_button_clicked(self, b):\n        \"\"\"\n        Callback function to handle button click events.\"\"\"\n        with self.output:\n            self.output.clear_output()\n            print(\n                f\"GeoJSON file will be saved to Downloads folder under this name:{self.buffer_radius.value}ft.csv\"\n            )\n\n            import io\n\n            if self.file_upload.value:\n                # For the first file (if multiple=False)\n                file_info = self.file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()  # file content as bytes\n                points = pd.read_csv(io.BytesIO(content_bytes))\n                lat_cols = [\"lat\", \"latitude\", \"y\", \"LAT\", \"Latitude\", \"Lat\", \"Y\"]\n                lon_cols = [\n                    \"lon\",\n                    \"long\",\n                    \"longitude\",\n                    \"x\",\n                    \"LON\",\n                    \"Longitude\",\n                    \"Long\",\n                    \"X\",\n                ]\n                id_cols = [\"id\", \"ID\", \"plot_ID\", \"plot_id\", \"plotID\", \"plotId\"]\n\n                def find_column(possible_names, columns):\n                    for name in possible_names:\n                        if name in columns:\n                            return name\n                    # fallback: check case-insensitive match\n                    lower_columns = {c.lower(): c for c in columns}\n                    for name in possible_names:\n                        if name.lower() in lower_columns:\n                            return lower_columns[name.lower()]\n                    raise ValueError(f\"No matching column found for {possible_names}\")\n\n                lat_col = find_column(lat_cols, points.columns)\n                lon_col = find_column(lon_cols, points.columns)\n                id_col = find_column(id_cols, points.columns)\n                points = points.rename(\n                    columns={lat_col: \"LAT\", lon_col: \"LON\", id_col: \"plot_ID\"}\n                )\n            else:\n                print(\"Please upload a CSV file.\")\n\n            radius_ft = self.buffer_radius.value\n\n            out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n            output_file = f\"{radius_ft}ft.csv\"\n            out_path = os.path.join(out_dir, output_file)\n\n            self.obfuscate_points(\n                data=points,\n                radius_feet=radius_ft,\n                plot_id_col=\"plot_ID\",\n                output_file=out_path,\n            )\n            print(f\"Buffered coordinates saved to {out_path}\")\n\n    def on_dropdown_change(self, change):\n        \"\"\"\n        Callback function to handle dropdown value changes.\n        \"\"\"\n        if change[\"new\"]:\n            with self.output:\n                self.output.clear_output()\n                catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n                data = self.fetch_geojson(catalog)\n                data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n                change_value = str(change[\"new\"])\n                url = data_dict.get(change_value)\n                print(f\"Selected dataset: {change['new']}\")\n                print(f\"URL: {url}\")\n\n    def create_obfuscated_point(self, point, radius_feet, crs=\"EPSG:4326\"):\n        \"\"\"\n        Create a circle polygon (as a shapely geometry) with the given radius in feet,\n        where the provided point is randomly located inside the circle (not at the center).\n        \"\"\"\n        # Convert radius from feet to meters\n        radius_m = radius_feet * 0.3048\n\n        # Project to local UTM for accurate distance calculations\n        utm_crs = f\"EPSG:326{int((point.x + 180) // 6) + 1}\"\n        transformer_to_utm = Transformer.from_crs(crs, utm_crs, always_xy=True)\n        transformer_to_latlon = Transformer.from_crs(utm_crs, crs, always_xy=True)\n        x, y = transformer_to_utm.transform(point.x, point.y)\n\n        # Randomize the point's location within the circle\n        angle = np.random.uniform(0, 2 * np.pi)\n        distance = np.random.uniform(0, radius_m)\n        # Calculate center of the circle so that the point is inside the circle but not at the center\n        center_x = x - distance * np.cos(angle)\n        center_y = y - distance * np.sin(angle)\n        center = Point(center_x, center_y)\n\n        # # Create the circle at the calculated center\n        # circle = center.buffer(radius_m, resolution=32)\n\n        # Transform the circle back to WGS84\n        center_latlon = shapely.ops.transform(\n            lambda x, y: transformer_to_latlon.transform(x, y), center\n        )\n        return center_latlon\n\n    def obfuscate_points(self, data, radius_feet, plot_id_col, output_file):\n        \"\"\"\n        Obfuscate points within a radius and save as csv.\n\n        Args:\n            data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n            radius_feet (float): Radius of the circle in feet.\n            plot_id_col (str): Column name for plot IDs.\n            output_file (str): Path to save the output GeoJSON file.\n        \"\"\"\n        if isinstance(data, str):\n            coordinates = pd.read_csv(data)\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        elif isinstance(data, pd.DataFrame):\n            coordinates = data\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        else:\n            gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n        centers = []\n        ids = []\n        for idx, row in gdf.iterrows():\n            point = row[\"geometry\"]\n            center = self.create_obfuscated_point(point, radius_feet, crs=gdf.crs)\n            centers.append(center)\n            ids.append(row[plot_id_col])\n        df = pd.DataFrame(\n            {\n                plot_id_col: ids,\n                \"lat\": [p.y for p in centers],\n                \"lon\": [p.x for p in centers],\n            }\n        )\n        # point_df = pd.DataFrame(gdf_circles)\n        point_csv = df.to_csv()\n        with open(output_file, \"w\") as f:\n            f.write(point_csv)\n        print(f\"CSV saved to {output_file}\")\n        return point_csv\n\n    def fetch_geojson(self, url):\n        \"\"\"\n        Fetch GeoJSON data from a given URL.\n\n        Args:\n            url (str): URL to fetch the GeoJSON data from.\n        \"\"\"\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raises an exception for HTTP errors\n            geojson_data = response.json()  # Parse the JSON response\n            return geojson_data\n        except requests.exceptions.HTTPError as http_err:\n            print(f\"HTTP error occurred: {http_err}\")\n        except requests.exceptions.ConnectionError as conn_err:\n            print(f\"Error connecting to the server: {conn_err}\")\n        except Exception as err:\n            print(f\"An error occurred: {err}\")\n        return None\n</code></pre>"},{"location":"buffer_coordinates/#skiba.buffer_coordinates.BufferCoordinates.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initializes the buffer_coordinates class and sets up the GUI components. Part 1 of buffered coordinates approach which creates circles around points. (Part 2 is in buffer_method.py)</p> Source code in <code>skiba/buffer_coordinates.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the buffer_coordinates class and sets up the GUI components.\n    Part 1 of buffered coordinates approach which creates circles around points.\n    (Part 2 is in buffer_method.py)\n    \"\"\"\n    # File Upload\n    self.file_upload = widgets.FileUpload(\n        accept=\".csv, .txt\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n        multiple=False,  # True to accept multiple files upload else False\n    )\n\n    # Dropdown\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    data = self.fetch_geojson(url)\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n    self.dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n    self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n    self.buffer_radius = widgets.FloatText(\n        value=10,\n        description=\"Buffer radius (ft):\",\n        disabled=False,\n        display=\"flex\",\n        flex_flow=\"column\",\n        align_items=\"stretch\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    self.run_button = widgets.Button(\n        description=\"Run Query\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        icon=\"rotate right\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    self.output = widgets.Output()\n\n    self.run_button.on_click(self.on_button_clicked)\n\n    self.hbox = widgets.HBox(\n        [self.file_upload, self.dropdown, self.buffer_radius, self.run_button]\n    )\n\n    self.vbox = widgets.VBox([self.hbox, self.output])\n</code></pre>"},{"location":"buffer_coordinates/#skiba.buffer_coordinates.BufferCoordinates.create_obfuscated_point","title":"<code>create_obfuscated_point(self, point, radius_feet, crs='EPSG:4326')</code>","text":"<p>Create a circle polygon (as a shapely geometry) with the given radius in feet, where the provided point is randomly located inside the circle (not at the center).</p> Source code in <code>skiba/buffer_coordinates.py</code> <pre><code>def create_obfuscated_point(self, point, radius_feet, crs=\"EPSG:4326\"):\n    \"\"\"\n    Create a circle polygon (as a shapely geometry) with the given radius in feet,\n    where the provided point is randomly located inside the circle (not at the center).\n    \"\"\"\n    # Convert radius from feet to meters\n    radius_m = radius_feet * 0.3048\n\n    # Project to local UTM for accurate distance calculations\n    utm_crs = f\"EPSG:326{int((point.x + 180) // 6) + 1}\"\n    transformer_to_utm = Transformer.from_crs(crs, utm_crs, always_xy=True)\n    transformer_to_latlon = Transformer.from_crs(utm_crs, crs, always_xy=True)\n    x, y = transformer_to_utm.transform(point.x, point.y)\n\n    # Randomize the point's location within the circle\n    angle = np.random.uniform(0, 2 * np.pi)\n    distance = np.random.uniform(0, radius_m)\n    # Calculate center of the circle so that the point is inside the circle but not at the center\n    center_x = x - distance * np.cos(angle)\n    center_y = y - distance * np.sin(angle)\n    center = Point(center_x, center_y)\n\n    # # Create the circle at the calculated center\n    # circle = center.buffer(radius_m, resolution=32)\n\n    # Transform the circle back to WGS84\n    center_latlon = shapely.ops.transform(\n        lambda x, y: transformer_to_latlon.transform(x, y), center\n    )\n    return center_latlon\n</code></pre>"},{"location":"buffer_coordinates/#skiba.buffer_coordinates.BufferCoordinates.fetch_geojson","title":"<code>fetch_geojson(self, url)</code>","text":"<p>Fetch GeoJSON data from a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch the GeoJSON data from.</p> required Source code in <code>skiba/buffer_coordinates.py</code> <pre><code>def fetch_geojson(self, url):\n    \"\"\"\n    Fetch GeoJSON data from a given URL.\n\n    Args:\n        url (str): URL to fetch the GeoJSON data from.\n    \"\"\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # Raises an exception for HTTP errors\n        geojson_data = response.json()  # Parse the JSON response\n        return geojson_data\n    except requests.exceptions.HTTPError as http_err:\n        print(f\"HTTP error occurred: {http_err}\")\n    except requests.exceptions.ConnectionError as conn_err:\n        print(f\"Error connecting to the server: {conn_err}\")\n    except Exception as err:\n        print(f\"An error occurred: {err}\")\n    return None\n</code></pre>"},{"location":"buffer_coordinates/#skiba.buffer_coordinates.BufferCoordinates.obfuscate_points","title":"<code>obfuscate_points(self, data, radius_feet, plot_id_col, output_file)</code>","text":"<p>Obfuscate points within a radius and save as csv.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, pd.DataFrame, gpd.GeoDataFrame</code> <p>Input data (GeoJSON, DataFrame, or GeoDataFrame).</p> required <code>radius_feet</code> <code>float</code> <p>Radius of the circle in feet.</p> required <code>plot_id_col</code> <code>str</code> <p>Column name for plot IDs.</p> required <code>output_file</code> <code>str</code> <p>Path to save the output GeoJSON file.</p> required Source code in <code>skiba/buffer_coordinates.py</code> <pre><code>def obfuscate_points(self, data, radius_feet, plot_id_col, output_file):\n    \"\"\"\n    Obfuscate points within a radius and save as csv.\n\n    Args:\n        data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n        radius_feet (float): Radius of the circle in feet.\n        plot_id_col (str): Column name for plot IDs.\n        output_file (str): Path to save the output GeoJSON file.\n    \"\"\"\n    if isinstance(data, str):\n        coordinates = pd.read_csv(data)\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    elif isinstance(data, pd.DataFrame):\n        coordinates = data\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    else:\n        gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n    centers = []\n    ids = []\n    for idx, row in gdf.iterrows():\n        point = row[\"geometry\"]\n        center = self.create_obfuscated_point(point, radius_feet, crs=gdf.crs)\n        centers.append(center)\n        ids.append(row[plot_id_col])\n    df = pd.DataFrame(\n        {\n            plot_id_col: ids,\n            \"lat\": [p.y for p in centers],\n            \"lon\": [p.x for p in centers],\n        }\n    )\n    # point_df = pd.DataFrame(gdf_circles)\n    point_csv = df.to_csv()\n    with open(output_file, \"w\") as f:\n        f.write(point_csv)\n    print(f\"CSV saved to {output_file}\")\n    return point_csv\n</code></pre>"},{"location":"buffer_coordinates/#skiba.buffer_coordinates.BufferCoordinates.on_button_clicked","title":"<code>on_button_clicked(self, b)</code>","text":"<p>Callback function to handle button click events.</p> Source code in <code>skiba/buffer_coordinates.py</code> <pre><code>def on_button_clicked(self, b):\n    \"\"\"\n    Callback function to handle button click events.\"\"\"\n    with self.output:\n        self.output.clear_output()\n        print(\n            f\"GeoJSON file will be saved to Downloads folder under this name:{self.buffer_radius.value}ft.csv\"\n        )\n\n        import io\n\n        if self.file_upload.value:\n            # For the first file (if multiple=False)\n            file_info = self.file_upload.value[0]\n            content_bytes = file_info[\"content\"].tobytes()  # file content as bytes\n            points = pd.read_csv(io.BytesIO(content_bytes))\n            lat_cols = [\"lat\", \"latitude\", \"y\", \"LAT\", \"Latitude\", \"Lat\", \"Y\"]\n            lon_cols = [\n                \"lon\",\n                \"long\",\n                \"longitude\",\n                \"x\",\n                \"LON\",\n                \"Longitude\",\n                \"Long\",\n                \"X\",\n            ]\n            id_cols = [\"id\", \"ID\", \"plot_ID\", \"plot_id\", \"plotID\", \"plotId\"]\n\n            def find_column(possible_names, columns):\n                for name in possible_names:\n                    if name in columns:\n                        return name\n                # fallback: check case-insensitive match\n                lower_columns = {c.lower(): c for c in columns}\n                for name in possible_names:\n                    if name.lower() in lower_columns:\n                        return lower_columns[name.lower()]\n                raise ValueError(f\"No matching column found for {possible_names}\")\n\n            lat_col = find_column(lat_cols, points.columns)\n            lon_col = find_column(lon_cols, points.columns)\n            id_col = find_column(id_cols, points.columns)\n            points = points.rename(\n                columns={lat_col: \"LAT\", lon_col: \"LON\", id_col: \"plot_ID\"}\n            )\n        else:\n            print(\"Please upload a CSV file.\")\n\n        radius_ft = self.buffer_radius.value\n\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        output_file = f\"{radius_ft}ft.csv\"\n        out_path = os.path.join(out_dir, output_file)\n\n        self.obfuscate_points(\n            data=points,\n            radius_feet=radius_ft,\n            plot_id_col=\"plot_ID\",\n            output_file=out_path,\n        )\n        print(f\"Buffered coordinates saved to {out_path}\")\n</code></pre>"},{"location":"buffer_coordinates/#skiba.buffer_coordinates.BufferCoordinates.on_dropdown_change","title":"<code>on_dropdown_change(self, change)</code>","text":"<p>Callback function to handle dropdown value changes.</p> Source code in <code>skiba/buffer_coordinates.py</code> <pre><code>def on_dropdown_change(self, change):\n    \"\"\"\n    Callback function to handle dropdown value changes.\n    \"\"\"\n    if change[\"new\"]:\n        with self.output:\n            self.output.clear_output()\n            catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n            data = self.fetch_geojson(catalog)\n            data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n            change_value = str(change[\"new\"])\n            url = data_dict.get(change_value)\n            print(f\"Selected dataset: {change['new']}\")\n            print(f\"URL: {url}\")\n</code></pre>"},{"location":"buffer_method/","title":"buffer_method code","text":""},{"location":"buffer_method/#skiba.buffer_method.buffer_method","title":"<code> buffer_method        </code>","text":"Source code in <code>skiba/buffer_method.py</code> <pre><code>class buffer_method:\n    def __init__(self):\n        \"\"\"\n        Initializes the buffer_method class and sets up the GUI components.\n        Part 2 of buffered coordinates approach which accesses GEE datasets and extracts median values.\n        (Part 1 is in buffer_coordinates.py)\n        \"\"\"\n        # File Upload\n        self.file_upload = widgets.FileUpload(\n            accept=\".geojson\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n            multiple=False,  # True to accept multiple files upload else False\n        )\n        # Dropdown\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = buffer_method.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        self.dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n\n        self.start_date = widgets.DatePicker(description=\"Start Date\", disabled=False)\n        self.end_date = widgets.DatePicker(description=\"End Date\", disabled=False)\n\n        self.run_button = widgets.Button(\n            description=\"Run Query\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            icon=\"check\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        self.output = widgets.Output()\n\n        self.run_button.on_click(self.on_button_clicked)\n        self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n        self.hbox = widgets.HBox([self.file_upload, self.dropdown])\n\n        self.hbox_bottom = widgets.HBox(\n            [self.start_date, self.end_date, self.run_button]\n        )\n        self.vbox = widgets.VBox([self.hbox, self.hbox_bottom, self.output])\n\n    def on_dropdown_change(self, change):\n        \"\"\"\n        Callback function to handle dropdown value changes.\"\"\"\n        if change[\"new\"]:\n            with self.output:\n                self.output.clear_output()\n                catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n                data = buffer_method.fetch_geojson(catalog)\n                data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n                change_value = str(change[\"new\"])\n                url = data_dict.get(change_value)\n                print(f\"Selected dataset: {change['new']}\")\n                print(f\"URL: {url}\")\n\n    def on_button_clicked(self, b):\n        \"\"\"\n        Callback function to handle button click events.\n        \"\"\"\n        import io\n\n        with self.output:\n            self.output.clear_output()\n            print(\n                f\"You entered: {self.dropdown.value}. CSV file will be saved to Downloads folder under this name.\"\n            )\n\n            if self.file_upload.value:\n                file_info = self.file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()\n                filename = file_info[\"name\"]\n                print(f\"Filename: {filename}\")\n\n                # --- Modification: Read GeoJSON from bytes ---\n                # Use BytesIO to read the uploaded GeoJSON file\n                geojson_buffer = io.BytesIO(content_bytes)\n                points = gpd.read_file(geojson_buffer)\n            else:\n                print(\"Please upload a GeoJSON file.\")\n                return\n\n            geedata = self.dropdown.value\n            start_date = self.start_date.value\n            end_date = self.end_date.value\n\n            self.extract_median_values(\n                data=points, geedata=geedata, start_date=start_date, end_date=end_date\n            )\n\n    def extract_median_values(self, data, geedata, start_date, end_date, **kwargs):\n        \"\"\"\n        Extracts median values from a GEE dataset for the given geometry.\n\n        Args:\n            data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n            geedata (str): GEE dataset ID.\n            start_date (str): Start date for filtering the dataset.\n            end_date (str): End date for filtering the dataset.\n            **kwargs: Additional arguments for the GEE dataset.\n        \"\"\"\n\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        response = requests.get(url)\n        response.raise_for_status()  # Raises an exception for HTTP errors\n        geojson_data = response.json()\n        data_type = [item[\"type\"] for item in geojson_data if item[\"id\"] == geedata]\n        data_str = \" \".join(data_type)\n        start_date = str(start_date)\n        end_date = str(end_date)\n\n        if isinstance(data, str):\n            # Assume the file is a GeoJSON or Shapefile with polygons\n            gdf = gpd.read_file(data)\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", inplace=True)\n            else:\n                gdf = gdf.to_crs(\"EPSG:4326\")\n        elif isinstance(data, pd.DataFrame):\n            # If you have a DataFrame, it should already have a 'geometry' column with Polygon objects\n            # If not, you need to construct it-otherwise, just convert to GeoDataFrame\n            gdf = gpd.GeoDataFrame(data, geometry=\"geometry\")\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", inplace=True)\n            else:\n                gdf = gdf.to_crs(\"EPSG:4326\")\n        else:\n            # If already a GeoDataFrame\n            if data.crs is None:\n                gdf = data.set_crs(\"EPSG:4326\")\n            else:\n                gdf = data.to_crs(\"EPSG:4326\")\n\n        comp_results = pd.DataFrame()\n\n        for row in gdf.itertuples():\n            gdf_row = gdf.iloc[[row.Index]]\n            geojson = gdf_row.__geo_interface__\n            fc = gm.geojson_to_ee(geojson)\n\n            # Try loading as Image\n            if data_str == \"image\":\n                col = ee.Image(geedata)\n                col = ee.ImageCollection(col)\n\n            elif data_str == \"image_collection\":\n                col = ee.ImageCollection(geedata)\n                # If date filters are provided, apply them\n\n            else:\n                raise ValueError(\"Dataset ID is not a valid Image or ImageCollection.\")\n\n            if start_date is None and end_date is None:\n                col = col.filterDate(start_date, end_date)\n            else:\n                pass\n\n            zonal_stats = col.median().reduceRegion(\n                reducer=ee.Reducer.median(), geometry=fc.geometry()\n            )\n            print(\"Zonal Stats:\")\n            print(zonal_stats)\n            col = zonal_stats.getInfo()\n            print(col)\n\n            col = pd.DataFrame.from_dict(col, orient=\"index\")\n\n            print(col)\n            print(col.keys())\n            print(type(col))\n\n            # col['plot_ID'] = gdf_row['plot_ID'].values[0]\n            # col = pd.DataFrame(col)\n            comp_results = pd.concat([comp_results, col], axis=0)\n\n        # Load the GEE dataset as an image\n        name = geedata\n        file_name = name.replace(\"/\", \"_\")\n\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        output_file = f\"{file_name}.csv\"\n        out_path = os.path.join(out_dir, output_file)\n\n        # Retrieve data from the image using sampleRegions\n        sampled_data = comp_results.to_csv(out_path)\n        return sampled_data\n\n        # Try loading as FeatureCollection (convert to raster)\n\n        # Load the GEE dataset as an image\n        # geeimage = buffer_method.load_gee_as_image(geedata, start_date, end_date)\n        # name = geedata\n        # file_name = name.replace(\"/\", \"_\")\n\n        # out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        # output_file = f\"{file_name}.csv\"\n        # out_path = os.path.join(out_dir, output_file)\n\n        # # Retrieve data from the image using sampleRegions\n        # sampled_data = gm.zonal_statistics(geeimage, fc, out_path, stat_type=\"MEDIAN\")\n\n        # return sampled_data\n\n    def fetch_geojson(url):\n        \"\"\"\n        Fetches GeoJSON data from a given URL.\n\n        Args:\n            url (str): URL to the GeoJSON file.\"\"\"\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raises an exception for HTTP errors\n            geojson_data = response.json()  # Parse the JSON response\n            return geojson_data\n        except requests.exceptions.HTTPError as http_err:\n            print(f\"HTTP error occurred: {http_err}\")\n        except requests.exceptions.ConnectionError as conn_err:\n            print(f\"Error connecting to the server: {conn_err}\")\n        except Exception as err:\n            print(f\"An error occurred: {err}\")\n        return None\n\n    def create_dropdown():\n        \"\"\"\n        Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n        Args:\n            url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n        Returns:\n            ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n        \"\"\"\n\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n\n        data = buffer_method.fetch_geojson(url)\n\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n\n        dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n\n        return dropdown\n\n    def add_date_picker():\n        \"\"\"\n        Creates a date picker widget for selecting dates.\n\n        Returns:\n            ipywidgets.DatePicker: A date picker widget for selecting dates.\"\"\"\n        date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n\n        return date_picker\n\n    def load_gee_as_image(dataset_id, start_date=None, end_date=None, **kwargs):\n        \"\"\"\n        Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n        Optionally filters by start and end date if applicable.\n\n        Parameters:\n            dataset_id (str): The Earth Engine dataset ID.\n            start_date (str): Optional start date in 'YYYY-MM-DD' format.\n            end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n        Returns:\n            ee.Image: The resulting image.\n        \"\"\"\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        response = requests.get(url)\n        response.raise_for_status()  # Raises an exception for HTTP errors\n        geojson_data = response.json()\n        data_type = [item[\"type\"] for item in geojson_data if item[\"id\"] == dataset_id]\n        data_str = \" \".join(data_type)\n        start_date = str(start_date)\n        end_date = str(end_date)\n        # Try loading as Image\n        if data_str == \"image\":\n            img = ee.Image(dataset_id)\n            # If .getInfo() doesn't throw, it's an Image\n            # img.getInfo()\n            return img\n        elif data_str == \"image_collection\":\n            col = ee.ImageCollection(dataset_id)\n            # If date filters are provided, apply them\n            if start_date is None and end_date is None:\n                col = col.filterDate(start_date, end_date)\n            else:\n                pass\n            # Reduce to a single image (e.g., median composite)\n            img = col.median()\n            return img\n        # Try loading as FeatureCollection (convert to raster)\n        else:\n            # fc_temp = ee.FeatureCollection(dataset_id)\n            # if start_date is None and end_date is None:\n            #         fc_temp = fc_temp.filterDate(start_date, end_date)\n            # # Convert to raster: burn a value of 1 into a new image\n            # img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.median())\n            # img.getInfo()\n            # return img\n            # or print(f\"Dataset must be either an Image or Image Collection\")\n            raise ValueError(\"Dataset ID is not a valid Image or ImageCollection.\")\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initializes the buffer_method class and sets up the GUI components. Part 2 of buffered coordinates approach which accesses GEE datasets and extracts median values. (Part 1 is in buffer_coordinates.py)</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the buffer_method class and sets up the GUI components.\n    Part 2 of buffered coordinates approach which accesses GEE datasets and extracts median values.\n    (Part 1 is in buffer_coordinates.py)\n    \"\"\"\n    # File Upload\n    self.file_upload = widgets.FileUpload(\n        accept=\".geojson\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n        multiple=False,  # True to accept multiple files upload else False\n    )\n    # Dropdown\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    data = buffer_method.fetch_geojson(url)\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n    self.dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n\n    self.start_date = widgets.DatePicker(description=\"Start Date\", disabled=False)\n    self.end_date = widgets.DatePicker(description=\"End Date\", disabled=False)\n\n    self.run_button = widgets.Button(\n        description=\"Run Query\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        icon=\"check\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    self.output = widgets.Output()\n\n    self.run_button.on_click(self.on_button_clicked)\n    self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n    self.hbox = widgets.HBox([self.file_upload, self.dropdown])\n\n    self.hbox_bottom = widgets.HBox(\n        [self.start_date, self.end_date, self.run_button]\n    )\n    self.vbox = widgets.VBox([self.hbox, self.hbox_bottom, self.output])\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.add_date_picker","title":"<code>add_date_picker()</code>","text":"<p>Creates a date picker widget for selecting dates.</p> <p>Returns:</p> Type Description <code>ipywidgets.DatePicker</code> <p>A date picker widget for selecting dates.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def add_date_picker():\n    \"\"\"\n    Creates a date picker widget for selecting dates.\n\n    Returns:\n        ipywidgets.DatePicker: A date picker widget for selecting dates.\"\"\"\n    date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n\n    return date_picker\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.create_dropdown","title":"<code>create_dropdown()</code>","text":"<p>Creates an ipywidgets dropdown menu from a GeoJSON catalog.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the GeoJSON catalog. Defaults to the Opengeos catalog.</p> required <p>Returns:</p> Type Description <code>ipywidgets.Dropdown</code> <p>A dropdown widget with the names from the catalog.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def create_dropdown():\n    \"\"\"\n    Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n    Args:\n        url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n    Returns:\n        ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n    \"\"\"\n\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n\n    data = buffer_method.fetch_geojson(url)\n\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n\n    dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n\n    return dropdown\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.extract_median_values","title":"<code>extract_median_values(self, data, geedata, start_date, end_date, **kwargs)</code>","text":"<p>Extracts median values from a GEE dataset for the given geometry.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, pd.DataFrame, gpd.GeoDataFrame</code> <p>Input data (GeoJSON, DataFrame, or GeoDataFrame).</p> required <code>geedata</code> <code>str</code> <p>GEE dataset ID.</p> required <code>start_date</code> <code>str</code> <p>Start date for filtering the dataset.</p> required <code>end_date</code> <code>str</code> <p>End date for filtering the dataset.</p> required <code>**kwargs</code> <p>Additional arguments for the GEE dataset.</p> <code>{}</code> Source code in <code>skiba/buffer_method.py</code> <pre><code>def extract_median_values(self, data, geedata, start_date, end_date, **kwargs):\n    \"\"\"\n    Extracts median values from a GEE dataset for the given geometry.\n\n    Args:\n        data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n        geedata (str): GEE dataset ID.\n        start_date (str): Start date for filtering the dataset.\n        end_date (str): End date for filtering the dataset.\n        **kwargs: Additional arguments for the GEE dataset.\n    \"\"\"\n\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    response = requests.get(url)\n    response.raise_for_status()  # Raises an exception for HTTP errors\n    geojson_data = response.json()\n    data_type = [item[\"type\"] for item in geojson_data if item[\"id\"] == geedata]\n    data_str = \" \".join(data_type)\n    start_date = str(start_date)\n    end_date = str(end_date)\n\n    if isinstance(data, str):\n        # Assume the file is a GeoJSON or Shapefile with polygons\n        gdf = gpd.read_file(data)\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", inplace=True)\n        else:\n            gdf = gdf.to_crs(\"EPSG:4326\")\n    elif isinstance(data, pd.DataFrame):\n        # If you have a DataFrame, it should already have a 'geometry' column with Polygon objects\n        # If not, you need to construct it-otherwise, just convert to GeoDataFrame\n        gdf = gpd.GeoDataFrame(data, geometry=\"geometry\")\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", inplace=True)\n        else:\n            gdf = gdf.to_crs(\"EPSG:4326\")\n    else:\n        # If already a GeoDataFrame\n        if data.crs is None:\n            gdf = data.set_crs(\"EPSG:4326\")\n        else:\n            gdf = data.to_crs(\"EPSG:4326\")\n\n    comp_results = pd.DataFrame()\n\n    for row in gdf.itertuples():\n        gdf_row = gdf.iloc[[row.Index]]\n        geojson = gdf_row.__geo_interface__\n        fc = gm.geojson_to_ee(geojson)\n\n        # Try loading as Image\n        if data_str == \"image\":\n            col = ee.Image(geedata)\n            col = ee.ImageCollection(col)\n\n        elif data_str == \"image_collection\":\n            col = ee.ImageCollection(geedata)\n            # If date filters are provided, apply them\n\n        else:\n            raise ValueError(\"Dataset ID is not a valid Image or ImageCollection.\")\n\n        if start_date is None and end_date is None:\n            col = col.filterDate(start_date, end_date)\n        else:\n            pass\n\n        zonal_stats = col.median().reduceRegion(\n            reducer=ee.Reducer.median(), geometry=fc.geometry()\n        )\n        print(\"Zonal Stats:\")\n        print(zonal_stats)\n        col = zonal_stats.getInfo()\n        print(col)\n\n        col = pd.DataFrame.from_dict(col, orient=\"index\")\n\n        print(col)\n        print(col.keys())\n        print(type(col))\n\n        # col['plot_ID'] = gdf_row['plot_ID'].values[0]\n        # col = pd.DataFrame(col)\n        comp_results = pd.concat([comp_results, col], axis=0)\n\n    # Load the GEE dataset as an image\n    name = geedata\n    file_name = name.replace(\"/\", \"_\")\n\n    out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n    output_file = f\"{file_name}.csv\"\n    out_path = os.path.join(out_dir, output_file)\n\n    # Retrieve data from the image using sampleRegions\n    sampled_data = comp_results.to_csv(out_path)\n    return sampled_data\n\n    # Try loading as FeatureCollection (convert to raster)\n\n    # Load the GEE dataset as an image\n    # geeimage = buffer_method.load_gee_as_image(geedata, start_date, end_date)\n    # name = geedata\n    # file_name = name.replace(\"/\", \"_\")\n\n    # out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n    # output_file = f\"{file_name}.csv\"\n    # out_path = os.path.join(out_dir, output_file)\n\n    # # Retrieve data from the image using sampleRegions\n    # sampled_data = gm.zonal_statistics(geeimage, fc, out_path, stat_type=\"MEDIAN\")\n\n    # return sampled_data\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.fetch_geojson","title":"<code>fetch_geojson(url)</code>","text":"<p>Fetches GeoJSON data from a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the GeoJSON file.</p> required Source code in <code>skiba/buffer_method.py</code> <pre><code>def fetch_geojson(url):\n    \"\"\"\n    Fetches GeoJSON data from a given URL.\n\n    Args:\n        url (str): URL to the GeoJSON file.\"\"\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # Raises an exception for HTTP errors\n        geojson_data = response.json()  # Parse the JSON response\n        return geojson_data\n    except requests.exceptions.HTTPError as http_err:\n        print(f\"HTTP error occurred: {http_err}\")\n    except requests.exceptions.ConnectionError as conn_err:\n        print(f\"Error connecting to the server: {conn_err}\")\n    except Exception as err:\n        print(f\"An error occurred: {err}\")\n    return None\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.load_gee_as_image","title":"<code>load_gee_as_image(dataset_id, start_date=None, end_date=None, **kwargs)</code>","text":"<p>Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image. Optionally filters by start and end date if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The Earth Engine dataset ID.</p> required <code>start_date</code> <code>str</code> <p>Optional start date in 'YYYY-MM-DD' format.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>Optional end date in 'YYYY-MM-DD' format.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The resulting image.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def load_gee_as_image(dataset_id, start_date=None, end_date=None, **kwargs):\n    \"\"\"\n    Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n    Optionally filters by start and end date if applicable.\n\n    Parameters:\n        dataset_id (str): The Earth Engine dataset ID.\n        start_date (str): Optional start date in 'YYYY-MM-DD' format.\n        end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        ee.Image: The resulting image.\n    \"\"\"\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    response = requests.get(url)\n    response.raise_for_status()  # Raises an exception for HTTP errors\n    geojson_data = response.json()\n    data_type = [item[\"type\"] for item in geojson_data if item[\"id\"] == dataset_id]\n    data_str = \" \".join(data_type)\n    start_date = str(start_date)\n    end_date = str(end_date)\n    # Try loading as Image\n    if data_str == \"image\":\n        img = ee.Image(dataset_id)\n        # If .getInfo() doesn't throw, it's an Image\n        # img.getInfo()\n        return img\n    elif data_str == \"image_collection\":\n        col = ee.ImageCollection(dataset_id)\n        # If date filters are provided, apply them\n        if start_date is None and end_date is None:\n            col = col.filterDate(start_date, end_date)\n        else:\n            pass\n        # Reduce to a single image (e.g., median composite)\n        img = col.median()\n        return img\n    # Try loading as FeatureCollection (convert to raster)\n    else:\n        # fc_temp = ee.FeatureCollection(dataset_id)\n        # if start_date is None and end_date is None:\n        #         fc_temp = fc_temp.filterDate(start_date, end_date)\n        # # Convert to raster: burn a value of 1 into a new image\n        # img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.median())\n        # img.getInfo()\n        # return img\n        # or print(f\"Dataset must be either an Image or Image Collection\")\n        raise ValueError(\"Dataset ID is not a valid Image or ImageCollection.\")\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.on_button_clicked","title":"<code>on_button_clicked(self, b)</code>","text":"<p>Callback function to handle button click events.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def on_button_clicked(self, b):\n    \"\"\"\n    Callback function to handle button click events.\n    \"\"\"\n    import io\n\n    with self.output:\n        self.output.clear_output()\n        print(\n            f\"You entered: {self.dropdown.value}. CSV file will be saved to Downloads folder under this name.\"\n        )\n\n        if self.file_upload.value:\n            file_info = self.file_upload.value[0]\n            content_bytes = file_info[\"content\"].tobytes()\n            filename = file_info[\"name\"]\n            print(f\"Filename: {filename}\")\n\n            # --- Modification: Read GeoJSON from bytes ---\n            # Use BytesIO to read the uploaded GeoJSON file\n            geojson_buffer = io.BytesIO(content_bytes)\n            points = gpd.read_file(geojson_buffer)\n        else:\n            print(\"Please upload a GeoJSON file.\")\n            return\n\n        geedata = self.dropdown.value\n        start_date = self.start_date.value\n        end_date = self.end_date.value\n\n        self.extract_median_values(\n            data=points, geedata=geedata, start_date=start_date, end_date=end_date\n        )\n</code></pre>"},{"location":"buffer_method/#skiba.buffer_method.buffer_method.on_dropdown_change","title":"<code>on_dropdown_change(self, change)</code>","text":"<p>Callback function to handle dropdown value changes.</p> Source code in <code>skiba/buffer_method.py</code> <pre><code>def on_dropdown_change(self, change):\n    \"\"\"\n    Callback function to handle dropdown value changes.\"\"\"\n    if change[\"new\"]:\n        with self.output:\n            self.output.clear_output()\n            catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n            data = buffer_method.fetch_geojson(catalog)\n            data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n            change_value = str(change[\"new\"])\n            url = data_dict.get(change_value)\n            print(f\"Selected dataset: {change['new']}\")\n            print(f\"URL: {url}\")\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#skiba.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>skiba/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/taraskiba/skiba/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>skiba could always use more documentation, whether as part of the official skiba docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/taraskiba/skiba/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up skiba for local development.</p> <ol> <li> <p>Fork the skiba repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/skiba.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv skiba\n$ cd skiba/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 skiba tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/taraskiba/skiba/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":"<p>Please see the streamlit app for FAQs (streamlit)</p> <p>Email me at: tskiba@vols.utk.edu[mailto:tskiba@vols.utk.edu]</p>"},{"location":"foliumcode/","title":"folium code","text":""},{"location":"foliumcode/#skiba.foliumcode.Map","title":"<code> Map            (Map)         </code>","text":"<p>A custom Map class that extends folium.Map.</p> Source code in <code>skiba/foliumcode.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"A custom Map class that extends folium.Map.\"\"\"\n\n    def __init__(self, center=(0, 0), zoom=2, **kwargs):\n        \"\"\"Initializes the Map object.\n\n        Args:\n            center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n            zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n            **kwargs: Additional keyword arguments for the folium.Map class.\n        \"\"\"\n        super().__init__(location=center, zoom_start=zoom, **kwargs)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson = folium.GeoJson(data=geojson, **kwargs)\n        geojson.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n        \"\"\"Add a split map to the folium map. Can handle TIF files.\n\n        Args:\n            left (str, optional): basemap for left side. Defaults to \"openstreetmap\".\n            right (str, optional): basemap for right side. Defaults to \"cartodbpositron\".\n        \"\"\"\n\n        from localtileserver import TileClient, get_folium_tile_layer\n\n        # map_types = {\n        #     \"ROADMAP\": \"m\",\n        #     \"SATELLITE\": \"s\",\n        #     \"HYBRID\": \"y\",\n        #     \"TERRAIN\": \"p\",\n        # }\n\n        # map_type = map_types[map_type.upper()]\n\n        # url = (\n        #     f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        # )\n        def _create_layer(source, **kwargs):\n            if str(source).lower().endswith((\".tif\", \".tiff\")):\n                # Create a TileClient for the raster file\n                tile_client = TileClient(source)\n                # Generate a Folium tile layer from the TileClient\n                return get_folium_tile_layer(tile_client, **kwargs)\n            else:\n                # Create a standard Folium TileLayer for basemaps\n                return folium.TileLayer(source, **kwargs)\n\n        layer_right = _create_layer(right, **kwargs)\n        layer_left = _create_layer(left, **kwargs)\n\n        sbs = folium.plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n        sbs.add_to(self)\n\n    def change_basemap(self, **kwargs):\n        \"\"\"Changes the basemap of the map.\n\n        Args:\n            **kwargs: Additional keyword arguments for the folium.TileLayer class.\n        \"\"\"\n        from ipywidgets import jslink, Dropdown\n        from ipyleaflet import WidgetControl\n\n        # Step 4: Create the dropdown\n        data_dict = {\n            \"OpenStreetMap\": \"openstreetmap\",\n            \"CartoDB Positron\": \"cartodbpositron\",\n            \"Stamen Terrain\": \"stamenterrain\",\n            \"Stamen Toner\": \"stamentoner\",\n            \"Stamen Watercolor\": \"stamenwatercolor\",\n        }\n        dropdown = Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n\n        basemap_layer = self.layers[1]\n        jslink((dropdown, \"value\"), (basemap_layer, \"basemap\"))\n        dropdown = WidgetControl(widget=dropdown, position=\"topright\")\n\n        self.add(dropdown)\n\n    def on_dropdown_change(change):\n        if change[\"new\"]:\n            m.add_basemap(change[\"new\"])\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.__init__","title":"<code>__init__(self, center=(0, 0), zoom=2, **kwargs)</code>  <code>special</code>","text":"<p>Initializes the Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>The initial center of the map as (latitude, longitude). Defaults to (0, 0).</p> <code>(0, 0)</code> <code>zoom</code> <code>int</code> <p>The initial zoom level of the map. Defaults to 2.</p> <code>2</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.Map class.</p> <code>{}</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def __init__(self, center=(0, 0), zoom=2, **kwargs):\n    \"\"\"Initializes the Map object.\n\n    Args:\n        center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n        zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n        **kwargs: Additional keyword arguments for the folium.Map class.\n    \"\"\"\n    super().__init__(location=center, zoom_start=zoom, **kwargs)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.GeoJson layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson = folium.GeoJson(data=geojson, **kwargs)\n    geojson.add_to(self)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_split_map","title":"<code>add_split_map(self, left='openstreetmap', right='cartodbpositron', **kwargs)</code>","text":"<p>Add a split map to the folium map. Can handle TIF files.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>basemap for left side. Defaults to \"openstreetmap\".</p> <code>'openstreetmap'</code> <code>right</code> <code>str</code> <p>basemap for right side. Defaults to \"cartodbpositron\".</p> <code>'cartodbpositron'</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n    \"\"\"Add a split map to the folium map. Can handle TIF files.\n\n    Args:\n        left (str, optional): basemap for left side. Defaults to \"openstreetmap\".\n        right (str, optional): basemap for right side. Defaults to \"cartodbpositron\".\n    \"\"\"\n\n    from localtileserver import TileClient, get_folium_tile_layer\n\n    # map_types = {\n    #     \"ROADMAP\": \"m\",\n    #     \"SATELLITE\": \"s\",\n    #     \"HYBRID\": \"y\",\n    #     \"TERRAIN\": \"p\",\n    # }\n\n    # map_type = map_types[map_type.upper()]\n\n    # url = (\n    #     f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    # )\n    def _create_layer(source, **kwargs):\n        if str(source).lower().endswith((\".tif\", \".tiff\")):\n            # Create a TileClient for the raster file\n            tile_client = TileClient(source)\n            # Generate a Folium tile layer from the TileClient\n            return get_folium_tile_layer(tile_client, **kwargs)\n        else:\n            # Create a standard Folium TileLayer for basemaps\n            return folium.TileLayer(source, **kwargs)\n\n    layer_right = _create_layer(right, **kwargs)\n    layer_left = _create_layer(left, **kwargs)\n\n    sbs = folium.plugins.SideBySideLayers(\n        layer_left=layer_left, layer_right=layer_right\n    )\n\n    layer_left.add_to(self)\n    layer_right.add_to(self)\n    sbs.add_to(self)\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/foliumcode.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"foliumcode/#skiba.foliumcode.Map.change_basemap","title":"<code>change_basemap(self, **kwargs)</code>","text":"<p>Changes the basemap of the map.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments for the folium.TileLayer class.</p> <code>{}</code> Source code in <code>skiba/foliumcode.py</code> <pre><code>def change_basemap(self, **kwargs):\n    \"\"\"Changes the basemap of the map.\n\n    Args:\n        **kwargs: Additional keyword arguments for the folium.TileLayer class.\n    \"\"\"\n    from ipywidgets import jslink, Dropdown\n    from ipyleaflet import WidgetControl\n\n    # Step 4: Create the dropdown\n    data_dict = {\n        \"OpenStreetMap\": \"openstreetmap\",\n        \"CartoDB Positron\": \"cartodbpositron\",\n        \"Stamen Terrain\": \"stamenterrain\",\n        \"Stamen Toner\": \"stamentoner\",\n        \"Stamen Watercolor\": \"stamenwatercolor\",\n    }\n    dropdown = Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n\n    basemap_layer = self.layers[1]\n    jslink((dropdown, \"value\"), (basemap_layer, \"basemap\"))\n    dropdown = WidgetControl(widget=dropdown, position=\"topright\")\n\n    self.add(dropdown)\n</code></pre>"},{"location":"geojson_buffering/","title":"geojson_buffering module","text":""},{"location":"geojson_buffering/#skiba.geojson_buffering.buffer_coordinates","title":"<code> buffer_coordinates        </code>","text":"Source code in <code>skiba/geojson_buffering.py</code> <pre><code>class buffer_coordinates:\n    def __init__(self):\n        \"\"\"\n        Initializes the buffer_coordinates class and sets up the GUI components.\n        Part 1 of buffered coordinates approach which creates circles around points.\n        (Part 2 is in buffer_method.py)\n        \"\"\"\n        # File Upload\n        self.file_upload = widgets.FileUpload(\n            accept=\".csv, .txt\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n            multiple=False,  # True to accept multiple files upload else False\n        )\n\n        # Dropdown\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = self.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        self.dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n        self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n        self.buffer_radius = widgets.FloatText(\n            value=10,\n            description=\"Buffer radius (ft):\",\n            disabled=False,\n            display=\"flex\",\n            flex_flow=\"column\",\n            align_items=\"stretch\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        self.run_button = widgets.Button(\n            description=\"Run Query\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            icon=\"rotate right\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        self.output = widgets.Output()\n\n        self.run_button.on_click(self.on_button_clicked)\n\n        self.hbox = widgets.HBox(\n            [self.file_upload, self.buffer_radius, self.run_button]\n        )\n\n        self.vbox = widgets.VBox([self.hbox, self.output])\n\n    def on_button_clicked(self, b):\n        \"\"\"\n        Callback function to handle button click events.\"\"\"\n        with self.output:\n            self.output.clear_output()\n            print(\n                f\"GeoJSON file will be saved to Downloads folder under this name:{self.buffer_radius.value}.0.geojson\"\n            )\n\n            import io\n\n            if self.file_upload.value:\n                # For the first file (if multiple=False)\n                file_info = self.file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()  # file content as bytes\n                filename = file_info[\"name\"]\n                print(f\"Filename: {filename}\")\n                points = pd.read_csv(io.BytesIO(content_bytes))\n                lat_cols = [\"lat\", \"latitude\", \"y\", \"LAT\", \"Latitude\", \"Lat\", \"Y\"]\n                lon_cols = [\n                    \"lon\",\n                    \"long\",\n                    \"longitude\",\n                    \"x\",\n                    \"LON\",\n                    \"Longitude\",\n                    \"Long\",\n                    \"X\",\n                ]\n                id_cols = [\"id\", \"ID\", \"plot_ID\", \"plot_id\", \"plotID\", \"plotId\"]\n\n                def find_column(possible_names, columns):\n                    for name in possible_names:\n                        if name in columns:\n                            return name\n                    # fallback: check case-insensitive match\n                    lower_columns = {c.lower(): c for c in columns}\n                    for name in possible_names:\n                        if name.lower() in lower_columns:\n                            return lower_columns[name.lower()]\n                    raise ValueError(f\"No matching column found for {possible_names}\")\n\n                lat_col = find_column(lat_cols, points.columns)\n                lon_col = find_column(lon_cols, points.columns)\n                id_col = find_column(id_cols, points.columns)\n                points = points.rename(\n                    columns={lat_col: \"LAT\", lon_col: \"LON\", id_col: \"plot_ID\"}\n                )\n            else:\n                print(\"Please upload a CSV file.\")\n\n            radius_ft = self.buffer_radius.value\n\n            out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n            output_file = f\"{radius_ft}.geojson\"\n            out_path = os.path.join(out_dir, output_file)\n\n            self.obfuscate_points_to_circles(\n                data=points,\n                radius_feet=radius_ft,\n                plot_id_col=\"plot_ID\",\n                output_file=out_path,\n            )\n            print(f\"Buffered coordinates GeoJSON saved to {out_path}\")\n\n    def on_dropdown_change(self, change):\n        \"\"\"\n        Callback function to handle dropdown value changes.\n        \"\"\"\n        if change[\"new\"]:\n            with self.output:\n                self.output.clear_output()\n                catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n                data = self.fetch_geojson(catalog)\n                data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n                change_value = str(change[\"new\"])\n                url = data_dict.get(change_value)\n                print(f\"Selected dataset: {change['new']}\")\n                print(f\"URL: {url}\")\n\n    def create_obfuscated_circle(self, point, radius_feet, crs=\"EPSG:4326\"):\n        \"\"\"\n        Create a circle polygon (as a shapely geometry) with the given radius in feet,\n        where the provided point is randomly located inside the circle (not at the center).\n        \"\"\"\n        # Convert radius from feet to meters\n        radius_m = radius_feet * 0.3048\n\n        # Project to local UTM for accurate distance calculations\n        utm_crs = f\"EPSG:326{int((point.x + 180) // 6) + 1}\"\n        transformer_to_utm = Transformer.from_crs(crs, utm_crs, always_xy=True)\n        transformer_to_latlon = Transformer.from_crs(utm_crs, crs, always_xy=True)\n        x, y = transformer_to_utm.transform(point.x, point.y)\n\n        # Randomize the point's location within the circle\n        # angle = np.random.uniform(0, 2 * np.pi)\n        # distance = np.random.uniform(0, radius_m)\n        # # Calculate center of the circle so that the point is inside the circle but not at the center\n        # center_x = x - distance * np.cos(angle)\n        # center_y = y - distance * np.sin(angle)\n        center = Point(x, y)  # Point(center_x, center_y)\n\n        # Create the circle at the calculated center\n        circle = center.buffer(radius_m, resolution=32)\n\n        # Transform the circle back to WGS84\n        circle_latlon = shapely.ops.transform(\n            lambda x, y: transformer_to_latlon.transform(x, y), circle\n        )\n        return circle_latlon\n\n    def obfuscate_points_to_circles(self, data, radius_feet, plot_id_col, output_file):\n        \"\"\"\n        Obfuscate points to circles and save as GeoJSON.\n\n        Args:\n            data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n            radius_feet (float): Radius of the circle in feet.\n            plot_id_col (str): Column name for plot IDs.\n            output_file (str): Path to save the output GeoJSON file.\n        \"\"\"\n        if isinstance(data, str):\n            coordinates = pd.read_csv(data)\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        elif isinstance(data, pd.DataFrame):\n            coordinates = data\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        else:\n            gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n        circles = []\n        ids = []\n        for idx, row in gdf.iterrows():\n            point = row[\"geometry\"]\n            circle = self.create_obfuscated_circle(point, radius_feet, crs=gdf.crs)\n            circles.append(circle)\n            ids.append(row[plot_id_col])\n        # Create new GeoDataFrame\n        gdf_circles = gpd.GeoDataFrame(\n            {plot_id_col: ids, \"geometry\": circles}, crs=gdf.crs\n        )\n        geojson_str = gdf_circles.to_json()\n        with open(output_file, \"w\") as f:\n            f.write(geojson_str)\n        print(f\"GeoJSON saved to {output_file}\")\n        return gdf_circles\n\n    def fetch_geojson(self, url):\n        \"\"\"\n        Fetch GeoJSON data from a given URL.\n\n        Args:\n            url (str): URL to fetch the GeoJSON data from.\n        \"\"\"\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raises an exception for HTTP errors\n            geojson_data = response.json()  # Parse the JSON response\n            return geojson_data\n        except requests.exceptions.HTTPError as http_err:\n            print(f\"HTTP error occurred: {http_err}\")\n        except requests.exceptions.ConnectionError as conn_err:\n            print(f\"Error connecting to the server: {conn_err}\")\n        except Exception as err:\n            print(f\"An error occurred: {err}\")\n        return None\n</code></pre>"},{"location":"geojson_buffering/#skiba.geojson_buffering.buffer_coordinates.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initializes the buffer_coordinates class and sets up the GUI components. Part 1 of buffered coordinates approach which creates circles around points. (Part 2 is in buffer_method.py)</p> Source code in <code>skiba/geojson_buffering.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the buffer_coordinates class and sets up the GUI components.\n    Part 1 of buffered coordinates approach which creates circles around points.\n    (Part 2 is in buffer_method.py)\n    \"\"\"\n    # File Upload\n    self.file_upload = widgets.FileUpload(\n        accept=\".csv, .txt\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n        multiple=False,  # True to accept multiple files upload else False\n    )\n\n    # Dropdown\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    data = self.fetch_geojson(url)\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n    self.dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n    self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n\n    self.buffer_radius = widgets.FloatText(\n        value=10,\n        description=\"Buffer radius (ft):\",\n        disabled=False,\n        display=\"flex\",\n        flex_flow=\"column\",\n        align_items=\"stretch\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    self.run_button = widgets.Button(\n        description=\"Run Query\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        icon=\"rotate right\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    self.output = widgets.Output()\n\n    self.run_button.on_click(self.on_button_clicked)\n\n    self.hbox = widgets.HBox(\n        [self.file_upload, self.buffer_radius, self.run_button]\n    )\n\n    self.vbox = widgets.VBox([self.hbox, self.output])\n</code></pre>"},{"location":"geojson_buffering/#skiba.geojson_buffering.buffer_coordinates.create_obfuscated_circle","title":"<code>create_obfuscated_circle(self, point, radius_feet, crs='EPSG:4326')</code>","text":"<p>Create a circle polygon (as a shapely geometry) with the given radius in feet, where the provided point is randomly located inside the circle (not at the center).</p> Source code in <code>skiba/geojson_buffering.py</code> <pre><code>def create_obfuscated_circle(self, point, radius_feet, crs=\"EPSG:4326\"):\n    \"\"\"\n    Create a circle polygon (as a shapely geometry) with the given radius in feet,\n    where the provided point is randomly located inside the circle (not at the center).\n    \"\"\"\n    # Convert radius from feet to meters\n    radius_m = radius_feet * 0.3048\n\n    # Project to local UTM for accurate distance calculations\n    utm_crs = f\"EPSG:326{int((point.x + 180) // 6) + 1}\"\n    transformer_to_utm = Transformer.from_crs(crs, utm_crs, always_xy=True)\n    transformer_to_latlon = Transformer.from_crs(utm_crs, crs, always_xy=True)\n    x, y = transformer_to_utm.transform(point.x, point.y)\n\n    # Randomize the point's location within the circle\n    # angle = np.random.uniform(0, 2 * np.pi)\n    # distance = np.random.uniform(0, radius_m)\n    # # Calculate center of the circle so that the point is inside the circle but not at the center\n    # center_x = x - distance * np.cos(angle)\n    # center_y = y - distance * np.sin(angle)\n    center = Point(x, y)  # Point(center_x, center_y)\n\n    # Create the circle at the calculated center\n    circle = center.buffer(radius_m, resolution=32)\n\n    # Transform the circle back to WGS84\n    circle_latlon = shapely.ops.transform(\n        lambda x, y: transformer_to_latlon.transform(x, y), circle\n    )\n    return circle_latlon\n</code></pre>"},{"location":"geojson_buffering/#skiba.geojson_buffering.buffer_coordinates.fetch_geojson","title":"<code>fetch_geojson(self, url)</code>","text":"<p>Fetch GeoJSON data from a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch the GeoJSON data from.</p> required Source code in <code>skiba/geojson_buffering.py</code> <pre><code>def fetch_geojson(self, url):\n    \"\"\"\n    Fetch GeoJSON data from a given URL.\n\n    Args:\n        url (str): URL to fetch the GeoJSON data from.\n    \"\"\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # Raises an exception for HTTP errors\n        geojson_data = response.json()  # Parse the JSON response\n        return geojson_data\n    except requests.exceptions.HTTPError as http_err:\n        print(f\"HTTP error occurred: {http_err}\")\n    except requests.exceptions.ConnectionError as conn_err:\n        print(f\"Error connecting to the server: {conn_err}\")\n    except Exception as err:\n        print(f\"An error occurred: {err}\")\n    return None\n</code></pre>"},{"location":"geojson_buffering/#skiba.geojson_buffering.buffer_coordinates.obfuscate_points_to_circles","title":"<code>obfuscate_points_to_circles(self, data, radius_feet, plot_id_col, output_file)</code>","text":"<p>Obfuscate points to circles and save as GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, pd.DataFrame, gpd.GeoDataFrame</code> <p>Input data (GeoJSON, DataFrame, or GeoDataFrame).</p> required <code>radius_feet</code> <code>float</code> <p>Radius of the circle in feet.</p> required <code>plot_id_col</code> <code>str</code> <p>Column name for plot IDs.</p> required <code>output_file</code> <code>str</code> <p>Path to save the output GeoJSON file.</p> required Source code in <code>skiba/geojson_buffering.py</code> <pre><code>def obfuscate_points_to_circles(self, data, radius_feet, plot_id_col, output_file):\n    \"\"\"\n    Obfuscate points to circles and save as GeoJSON.\n\n    Args:\n        data (str, pd.DataFrame, gpd.GeoDataFrame): Input data (GeoJSON, DataFrame, or GeoDataFrame).\n        radius_feet (float): Radius of the circle in feet.\n        plot_id_col (str): Column name for plot IDs.\n        output_file (str): Path to save the output GeoJSON file.\n    \"\"\"\n    if isinstance(data, str):\n        coordinates = pd.read_csv(data)\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    elif isinstance(data, pd.DataFrame):\n        coordinates = data\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    else:\n        gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n    circles = []\n    ids = []\n    for idx, row in gdf.iterrows():\n        point = row[\"geometry\"]\n        circle = self.create_obfuscated_circle(point, radius_feet, crs=gdf.crs)\n        circles.append(circle)\n        ids.append(row[plot_id_col])\n    # Create new GeoDataFrame\n    gdf_circles = gpd.GeoDataFrame(\n        {plot_id_col: ids, \"geometry\": circles}, crs=gdf.crs\n    )\n    geojson_str = gdf_circles.to_json()\n    with open(output_file, \"w\") as f:\n        f.write(geojson_str)\n    print(f\"GeoJSON saved to {output_file}\")\n    return gdf_circles\n</code></pre>"},{"location":"geojson_buffering/#skiba.geojson_buffering.buffer_coordinates.on_button_clicked","title":"<code>on_button_clicked(self, b)</code>","text":"<p>Callback function to handle button click events.</p> Source code in <code>skiba/geojson_buffering.py</code> <pre><code>def on_button_clicked(self, b):\n    \"\"\"\n    Callback function to handle button click events.\"\"\"\n    with self.output:\n        self.output.clear_output()\n        print(\n            f\"GeoJSON file will be saved to Downloads folder under this name:{self.buffer_radius.value}.0.geojson\"\n        )\n\n        import io\n\n        if self.file_upload.value:\n            # For the first file (if multiple=False)\n            file_info = self.file_upload.value[0]\n            content_bytes = file_info[\"content\"].tobytes()  # file content as bytes\n            filename = file_info[\"name\"]\n            print(f\"Filename: {filename}\")\n            points = pd.read_csv(io.BytesIO(content_bytes))\n            lat_cols = [\"lat\", \"latitude\", \"y\", \"LAT\", \"Latitude\", \"Lat\", \"Y\"]\n            lon_cols = [\n                \"lon\",\n                \"long\",\n                \"longitude\",\n                \"x\",\n                \"LON\",\n                \"Longitude\",\n                \"Long\",\n                \"X\",\n            ]\n            id_cols = [\"id\", \"ID\", \"plot_ID\", \"plot_id\", \"plotID\", \"plotId\"]\n\n            def find_column(possible_names, columns):\n                for name in possible_names:\n                    if name in columns:\n                        return name\n                # fallback: check case-insensitive match\n                lower_columns = {c.lower(): c for c in columns}\n                for name in possible_names:\n                    if name.lower() in lower_columns:\n                        return lower_columns[name.lower()]\n                raise ValueError(f\"No matching column found for {possible_names}\")\n\n            lat_col = find_column(lat_cols, points.columns)\n            lon_col = find_column(lon_cols, points.columns)\n            id_col = find_column(id_cols, points.columns)\n            points = points.rename(\n                columns={lat_col: \"LAT\", lon_col: \"LON\", id_col: \"plot_ID\"}\n            )\n        else:\n            print(\"Please upload a CSV file.\")\n\n        radius_ft = self.buffer_radius.value\n\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        output_file = f\"{radius_ft}.geojson\"\n        out_path = os.path.join(out_dir, output_file)\n\n        self.obfuscate_points_to_circles(\n            data=points,\n            radius_feet=radius_ft,\n            plot_id_col=\"plot_ID\",\n            output_file=out_path,\n        )\n        print(f\"Buffered coordinates GeoJSON saved to {out_path}\")\n</code></pre>"},{"location":"geojson_buffering/#skiba.geojson_buffering.buffer_coordinates.on_dropdown_change","title":"<code>on_dropdown_change(self, change)</code>","text":"<p>Callback function to handle dropdown value changes.</p> Source code in <code>skiba/geojson_buffering.py</code> <pre><code>def on_dropdown_change(self, change):\n    \"\"\"\n    Callback function to handle dropdown value changes.\n    \"\"\"\n    if change[\"new\"]:\n        with self.output:\n            self.output.clear_output()\n            catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n            data = self.fetch_geojson(catalog)\n            data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n            change_value = str(change[\"new\"])\n            url = data_dict.get(change_value)\n            print(f\"Selected dataset: {change['new']}\")\n            print(f\"URL: {url}\")\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install skiba, run this command in your terminal:</p> <pre><code>pip install skiba\n</code></pre> <p>This is the preferred method to install skiba, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install skiba from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/taraskiba/skiba\n</code></pre>"},{"location":"interactive/","title":"interactive module","text":""},{"location":"interactive/#skiba.interactive.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>skiba/interactive.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[37.5, -95], zoom=4, height=\"600px\", **kwargs):\n        \"\"\"Initialize the map with a given center and zoom level.\n\n        Args:\n            center (list, optional): Center coordinates of the map. Defaults to [37.5, -95].\n            zoom (int, optional): Zoom level of the map. Defaults to 4.\n            height (str, optional): Height of the map. Defaults to \"600px\".\n            **kwargs: Additional keyword arguments for ipyleaflet.Map.\n        \"\"\"\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n        self.add_layer_control()\n        self.change_basemap()\n        self.add_search_marker()\n        self.upload_points()\n        self.upload_geojson_file()\n        self.change_built_in_shapefiles()\n        self.on_interaction(self.handle_click)\n        self.geojson_button()\n\n    def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def handle_click(self, **kwargs):\n        \"\"\"Handles click events on the map.\"\"\"\n        if kwargs.get(\"type\") == \"click\":\n            self.add_layer(ipyleaflet.Marker(location=kwargs.get(\"coordinates\")))\n\n            print(f\"Clicked at: {kwargs.get('coordinates')}\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_geojson(self, data, hover_style=None, **kwargs):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"gray\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        style = {\"color\": \"black\", \"weight\": 1, \"opacity\": 1}\n\n        if (\n            hasattr(self, \"current_geojson_layer\")\n            and self.current_geojson_layer is not None\n        ):\n            try:\n                self.remove_layer(self.current_geojson_layer)\n            except Exception:\n                pass  # Layer might have already been removed\n\n        layer = ipyleaflet.GeoJSON(\n            data=geojson, hover_style=hover_style, style=style, **kwargs\n        )\n        self.current_geojson_layer = layer\n        self.add_layer(layer)\n\n    def add_points(self, data, **kwargs):\n        \"\"\"Adds points to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n        \"\"\"\n\n        # Load data with safety checks\n        if isinstance(data, str):\n            coordinates = pd.read_csv(data)\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        elif isinstance(data, pd.DataFrame):\n            coordinates = data\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        else:\n            gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n        point_style = {\n            \"radius\": 2,\n            \"color\": \"black\",\n            \"dashArray\": \"2\",\n            \"fillOpacity\": 1,\n            \"fillColor\": \"red\",\n            \"weight\": 1,\n        }  # 'color': 'white',\n\n        geo_data = ipyleaflet.GeoData(\n            geo_dataframe=gdf,\n            point_style=point_style,\n        )\n\n        self.add(geo_data)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def upload_points(self, **kwargs):\n        \"\"\"Uploads points to the map.\"\"\"\n\n        from ipywidgets import FileUpload, Button, ToggleButton, HBox\n\n        button = Button(\n            description=\"Add Points\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            size=38,\n            icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        file_upload = FileUpload(\n            accept=\".csv\",\n            multiple=False,\n            size=38,\n            description=\"Upload CSV\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        close_button = ToggleButton(\n            icon=\"map-pin\", value=True, tooltip=\"Upload points from CSV file\"\n        )\n        close_button.layout = widgets.Layout(width=\"36px\", height=\"36px\")\n\n        hbox = HBox([close_button])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if is_open[0] and change[\"new\"]:\n                hbox.children = (close_button,)\n            else:\n                hbox.children = (close_button, file_upload, button)\n\n        def on_button_clicked(change):\n            \"\"\"Handles the file upload.\"\"\"\n            import io\n\n            if file_upload.value:\n                # For the first file (if multiple=False)\n                file_info = file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()\n                points = pd.read_csv(io.BytesIO(content_bytes))\n                self.add_points(points)\n\n        close_button.observe(on_toggle_change, names=\"value\")\n\n        button.on_click(on_button_clicked)\n\n        upload_control = ipyleaflet.WidgetControl(widget=hbox, position=\"topright\")\n        self.add_control(upload_control)\n\n    def upload_geojson_file(self, **kwargs):\n        \"\"\"Uploads GeoJSON file to the map.\"\"\"\n\n        from ipywidgets import FileUpload, Button, ToggleButton, HBox\n\n        button = Button(\n            description=\"Add GeoJSON file\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            size=38,\n            icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        file_upload = FileUpload(\n            accept=\".geojson\",\n            multiple=False,\n            size=38,\n            description=\"Upload GeoJSON\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        close_button = ToggleButton(icon=\"file\", value=True, tooltip=\"Add GeoJSON file\")\n        close_button.layout = widgets.Layout(width=\"36px\", height=\"36px\")\n\n        hbox = HBox([close_button])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if change[\"new\"]:\n                hbox.children = (close_button,)\n            else:\n                hbox.children = (close_button, file_upload, button)\n\n        def on_button_clicked(change):\n            \"\"\"Handles the url upload.\"\"\"\n            if file_upload.value and len(file_upload.value) &gt; 0:\n                import json\n                from ipyleaflet import GeoJSON\n\n                file_info = file_upload.value[0]\n                # Get bytes from memoryview\n                content_bytes = file_info[\"content\"].tobytes()\n                # Decode bytes to string, then load as JSON\n                geojson_data = json.loads(content_bytes.decode(\"utf-8\"))\n                # Add the GeoJSON layer to the map\n                geo_json = GeoJSON(data=geojson_data)\n                self.add_layer(geo_json)\n\n        close_button.observe(on_toggle_change, names=\"value\")\n\n        button.on_click(on_button_clicked)\n\n        upload_control = ipyleaflet.WidgetControl(widget=hbox, position=\"topright\")\n        self.add_control(upload_control)\n\n    def add_widgets(self):\n        \"\"\"Creates and displays widgets for user interaction.\"\"\"\n\n        from ipywidgets import jslink\n        from ipyleaflet import WidgetControl\n\n        # date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n        opacity_slider = widgets.FloatSlider(\n            value=1,\n            min=0,\n            max=1.0,\n            step=0.01,\n            description=\"Opacity\",\n            continuous_update=False,\n            orientation=\"horizontal\",\n            readout=True,\n            readout_format=\".2f\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        basemap_layer = self.layers[1]\n        jslink((opacity_slider, \"value\"), (basemap_layer, \"opacity\"))\n        opacity_control = WidgetControl(widget=opacity_slider, position=\"topright\")\n\n        self.add(opacity_control)\n        # self.add(date_control)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def change_basemap(self, **kwargs):\n        \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n        from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n        from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n        # Map dropdown names to actual basemap objects\n        BASEMAP_LOOKUP = {\n            \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n            \"OpenTopoMap\": basemaps.OpenTopoMap,\n            \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n            \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n            \"CartoDB.Positron\": basemaps.CartoDB.Positron,\n            \"CartoDB.PositronNoLabels\": basemaps.CartoDB.PositronNoLabels,\n            \"Esri.WorldTopoMap\": basemaps.Esri.WorldTopoMap,\n            \"Esri.WorldStreetMap\": basemaps.Esri.WorldStreetMap,\n            \"Esri.OceanBasemap\": basemaps.Esri.OceanBasemap,\n            \"Esri.NatGeoWorldMap\": basemaps.Esri.NatGeoWorldMap,\n            \"NASAGIBS.ModisTerraTrueColorCR\": basemaps.NASAGIBS.ModisTerraTrueColorCR,\n            \"NASAGIBS.ModisAquaTrueColorCR\": basemaps.NASAGIBS.ModisAquaTrueColorCR,\n            \"NASAGIBS.ViirsTrueColorCR\": basemaps.NASAGIBS.ViirsTrueColorCR,\n            \"NASAGIBS.ViirsEarthAtNight2012\": basemaps.NASAGIBS.ViirsEarthAtNight2012,\n        }\n\n        # Create widgets\n\n        toggle = ToggleButton(\n            value=True,\n            tooltip=\"Change basemap\",\n            icon=\"map-o\",\n            layout=Layout(width=\"36px\", height=\"36px\"),\n        )\n\n        dropdown = Dropdown(\n            options=list(BASEMAP_LOOKUP.keys()),\n            value=\"OpenStreetMap\",\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n            layout=Layout(width=\"250px\", height=\"36px\"),\n        )\n\n        # Store reference to current basemap layer\n        if not hasattr(self, \"current_basemap\"):\n            self.current_basemap = self.layers[0]\n\n        def on_dropdown_change(change):\n            \"\"\"Handle basemap selection changes\"\"\"\n            if change[\"new\"]:\n                new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n                self.substitute_layer(self.current_basemap, new_basemap)\n                self.current_basemap = new_basemap\n\n        # def on_toggle_change(change):\n        #     \"\"\"Toggle visibility of dropdown\"\"\"\n        #     if change[\"new\"]:\n        #         dropdown.layout.visibility = 'visible'  # Show dropdown\n        #     else:\n        #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n        # Set up event handlers\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        # Assemble and add control\n        widget_box = HBox([toggle])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if is_open[0] and change[\"new\"]:\n                widget_box.children = (toggle,)\n            else:\n                widget_box.children = (toggle, dropdown)\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        control = WidgetControl(widget=widget_box, position=\"topright\")\n        self.add_control(control)\n\n    def change_built_in_shapefiles(self, **kwargs):\n        \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n        from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n        from ipyleaflet import WidgetControl\n\n        # Map dropdown names to actual basemap objects\n        SHAPEFILE_LOOKUP = {\n            \"None\": None,\n            \"U.S. States\": \"../data/us-states.json\",\n            \"National Forests\": \"https://geohub.oregon.gov/api/download/v1/items/b479e4bd7d70439a87e0230c99bddce5/geojson?layers=0\",\n        }\n\n        # Create widgets\n        toggle = ToggleButton(\n            value=True,\n            tooltip=\"Add built-in shapefile\",\n            icon=\"square-o\",\n            layout=Layout(width=\"38px\", height=\"38px\"),\n        )\n\n        dropdown = Dropdown(\n            options=list(SHAPEFILE_LOOKUP.keys()),\n            value=\"None\",\n            placeholder=\"Select a shapefile\",\n            description=\"Select shapefile:\",\n            style={\"description_width\": \"initial\"},\n            layout=Layout(width=\"250px\", height=\"38px\"),\n        )\n\n        # Store reference to current basemap layer\n        if not hasattr(self, \"current_basemap\"):\n            self.current_basemap = self.layers[0]\n\n        def on_dropdown_change(change):\n            \"\"\"Handle shapefile selection changes\"\"\"\n            if change[\"new\"]:\n                geojson_path = SHAPEFILE_LOOKUP[change[\"new\"]]\n                if geojson_path is not None:\n                    self.add_geojson(geojson_path, name=change[\"new\"])\n                else:\n                    # Remove existing shapefile layer if \"None\" is selected\n                    if (\n                        hasattr(self, \"current_geojson_layer\")\n                        and self.current_geojson_layer is not None\n                    ):\n                        try:\n                            self.remove_layer(self.current_geojson_layer)\n                        except Exception:\n                            pass\n\n        # Set up event handlers\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        # Assemble and add control\n        widget_box = HBox([toggle])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if change[\"new\"]:\n                widget_box.children = (toggle,)\n            else:\n                widget_box.children = (toggle, dropdown)\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        control = WidgetControl(widget=widget_box, position=\"topright\")\n        self.add_control(control)\n\n    def add_search_marker(self, **kwargs):\n        \"\"\"Adds a search marker to the map.\"\"\"\n\n        from ipyleaflet import SearchControl, Marker, AwesomeIcon\n\n        search_marker = Marker(\n            icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\")\n        )\n\n        search_control = SearchControl(\n            position=\"topleft\",\n            url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\",\n            zoom=10,\n            marker=search_marker,\n        )\n\n        self.add(search_control)\n\n    def geojson_button(self, **kwargs):\n        \"\"\"Creates a button to add shapefiles.\"\"\"\n        from ipywidgets import Button, Text, ToggleButton, HBox, Layout\n        from ipyleaflet import WidgetControl\n\n        # Create widgets\n        toggle_close = ToggleButton(\n            value=True, tooltip=\"Add GeoJSON from link\", icon=\"link\"\n        )\n\n        url = Text(\n            placeholder=\"Type something\",\n            description=\"GeoJSON URL:\",\n            disabled=False,\n            style={\"description_width\": \"initial\"},\n        )\n\n        run_button = Button(\n            description=\"Add GeoJSON\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            size=38,\n            icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n        )\n\n        toggle_close.layout = Layout(width=\"36px\", height=\"36px\")\n\n        # Assemble and add control\n        widget_box = HBox([toggle_close])\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if change[\"new\"]:\n                widget_box.children = (toggle_close,)\n            else:\n                widget_box.children = (toggle_close, url, run_button)\n\n        def on_button_clicked(change):\n            \"\"\"Handles the url upload.\"\"\"\n            if url.value:\n                # For the first file (if multiple=False)\n                geojson_path = url.value\n                self.add_geojson(geojson_path, name=url.value)\n\n        toggle_close.observe(on_toggle_change, names=\"value\")\n\n        run_button.on_click(on_button_clicked)\n\n        control = WidgetControl(widget=widget_box, position=\"topright\")\n\n        self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.__init__","title":"<code>__init__(self, center=[37.5, -95], zoom=4, height='600px', **kwargs)</code>  <code>special</code>","text":"<p>Initialize the map with a given center and zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>list</code> <p>Center coordinates of the map. Defaults to [37.5, -95].</p> <code>[37.5, -95]</code> <code>zoom</code> <code>int</code> <p>Zoom level of the map. Defaults to 4.</p> <code>4</code> <code>height</code> <code>str</code> <p>Height of the map. Defaults to \"600px\".</p> <code>'600px'</code> <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.Map.</p> <code>{}</code> Source code in <code>skiba/interactive.py</code> <pre><code>def __init__(self, center=[37.5, -95], zoom=4, height=\"600px\", **kwargs):\n    \"\"\"Initialize the map with a given center and zoom level.\n\n    Args:\n        center (list, optional): Center coordinates of the map. Defaults to [37.5, -95].\n        zoom (int, optional): Zoom level of the map. Defaults to 4.\n        height (str, optional): Height of the map. Defaults to \"600px\".\n        **kwargs: Additional keyword arguments for ipyleaflet.Map.\n    \"\"\"\n    super().__init__(center=center, zoom=zoom, **kwargs)\n    self.layout.height = height\n    self.scroll_wheel_zoom = True\n    self.add_layer_control()\n    self.change_basemap()\n    self.add_search_marker()\n    self.upload_points()\n    self.upload_geojson_file()\n    self.change_built_in_shapefiles()\n    self.on_interaction(self.handle_click)\n    self.geojson_button()\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_basemap","title":"<code>add_basemap(self, basemap='Esri.WorldImagery')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"Esri.WorldImagery\".</p> <code>'Esri.WorldImagery'</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"Esri.WorldImagery\".\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_geojson","title":"<code>add_geojson(self, data, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> required <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_geojson(self, data, hover_style=None, **kwargs):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"gray\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    style = {\"color\": \"black\", \"weight\": 1, \"opacity\": 1}\n\n    if (\n        hasattr(self, \"current_geojson_layer\")\n        and self.current_geojson_layer is not None\n    ):\n        try:\n            self.remove_layer(self.current_geojson_layer)\n        except Exception:\n            pass  # Layer might have already been removed\n\n    layer = ipyleaflet.GeoJSON(\n        data=geojson, hover_style=hover_style, style=style, **kwargs\n    )\n    self.current_geojson_layer = layer\n    self.add_layer(layer)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_points","title":"<code>add_points(self, data, **kwargs)</code>","text":"<p>Adds points to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_points(self, data, **kwargs):\n    \"\"\"Adds points to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n    \"\"\"\n\n    # Load data with safety checks\n    if isinstance(data, str):\n        coordinates = pd.read_csv(data)\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    elif isinstance(data, pd.DataFrame):\n        coordinates = data\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    else:\n        gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n\n    point_style = {\n        \"radius\": 2,\n        \"color\": \"black\",\n        \"dashArray\": \"2\",\n        \"fillOpacity\": 1,\n        \"fillColor\": \"red\",\n        \"weight\": 1,\n    }  # 'color': 'white',\n\n    geo_data = ipyleaflet.GeoData(\n        geo_dataframe=gdf,\n        point_style=point_style,\n    )\n\n    self.add(geo_data)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_search_marker","title":"<code>add_search_marker(self, **kwargs)</code>","text":"<p>Adds a search marker to the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_search_marker(self, **kwargs):\n    \"\"\"Adds a search marker to the map.\"\"\"\n\n    from ipyleaflet import SearchControl, Marker, AwesomeIcon\n\n    search_marker = Marker(\n        icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\")\n    )\n\n    search_control = SearchControl(\n        position=\"topleft\",\n        url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\",\n        zoom=10,\n        marker=search_marker,\n    )\n\n    self.add(search_control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/interactive.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.add_widgets","title":"<code>add_widgets(self)</code>","text":"<p>Creates and displays widgets for user interaction.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def add_widgets(self):\n    \"\"\"Creates and displays widgets for user interaction.\"\"\"\n\n    from ipywidgets import jslink\n    from ipyleaflet import WidgetControl\n\n    # date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n    opacity_slider = widgets.FloatSlider(\n        value=1,\n        min=0,\n        max=1.0,\n        step=0.01,\n        description=\"Opacity\",\n        continuous_update=False,\n        orientation=\"horizontal\",\n        readout=True,\n        readout_format=\".2f\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    basemap_layer = self.layers[1]\n    jslink((opacity_slider, \"value\"), (basemap_layer, \"opacity\"))\n    opacity_control = WidgetControl(widget=opacity_slider, position=\"topright\")\n\n    self.add(opacity_control)\n    # self.add(date_control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.change_basemap","title":"<code>change_basemap(self, **kwargs)</code>","text":"<p>Changes the basemap of the map using a dropdown selector.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def change_basemap(self, **kwargs):\n    \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n    from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n    from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n    # Map dropdown names to actual basemap objects\n    BASEMAP_LOOKUP = {\n        \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n        \"OpenTopoMap\": basemaps.OpenTopoMap,\n        \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n        \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n        \"CartoDB.Positron\": basemaps.CartoDB.Positron,\n        \"CartoDB.PositronNoLabels\": basemaps.CartoDB.PositronNoLabels,\n        \"Esri.WorldTopoMap\": basemaps.Esri.WorldTopoMap,\n        \"Esri.WorldStreetMap\": basemaps.Esri.WorldStreetMap,\n        \"Esri.OceanBasemap\": basemaps.Esri.OceanBasemap,\n        \"Esri.NatGeoWorldMap\": basemaps.Esri.NatGeoWorldMap,\n        \"NASAGIBS.ModisTerraTrueColorCR\": basemaps.NASAGIBS.ModisTerraTrueColorCR,\n        \"NASAGIBS.ModisAquaTrueColorCR\": basemaps.NASAGIBS.ModisAquaTrueColorCR,\n        \"NASAGIBS.ViirsTrueColorCR\": basemaps.NASAGIBS.ViirsTrueColorCR,\n        \"NASAGIBS.ViirsEarthAtNight2012\": basemaps.NASAGIBS.ViirsEarthAtNight2012,\n    }\n\n    # Create widgets\n\n    toggle = ToggleButton(\n        value=True,\n        tooltip=\"Change basemap\",\n        icon=\"map-o\",\n        layout=Layout(width=\"36px\", height=\"36px\"),\n    )\n\n    dropdown = Dropdown(\n        options=list(BASEMAP_LOOKUP.keys()),\n        value=\"OpenStreetMap\",\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n        layout=Layout(width=\"250px\", height=\"36px\"),\n    )\n\n    # Store reference to current basemap layer\n    if not hasattr(self, \"current_basemap\"):\n        self.current_basemap = self.layers[0]\n\n    def on_dropdown_change(change):\n        \"\"\"Handle basemap selection changes\"\"\"\n        if change[\"new\"]:\n            new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n            self.substitute_layer(self.current_basemap, new_basemap)\n            self.current_basemap = new_basemap\n\n    # def on_toggle_change(change):\n    #     \"\"\"Toggle visibility of dropdown\"\"\"\n    #     if change[\"new\"]:\n    #         dropdown.layout.visibility = 'visible'  # Show dropdown\n    #     else:\n    #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n    # Set up event handlers\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    # Assemble and add control\n    widget_box = HBox([toggle])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if is_open[0] and change[\"new\"]:\n            widget_box.children = (toggle,)\n        else:\n            widget_box.children = (toggle, dropdown)\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    control = WidgetControl(widget=widget_box, position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.change_built_in_shapefiles","title":"<code>change_built_in_shapefiles(self, **kwargs)</code>","text":"<p>Changes the basemap of the map using a dropdown selector.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def change_built_in_shapefiles(self, **kwargs):\n    \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n    from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n    from ipyleaflet import WidgetControl\n\n    # Map dropdown names to actual basemap objects\n    SHAPEFILE_LOOKUP = {\n        \"None\": None,\n        \"U.S. States\": \"../data/us-states.json\",\n        \"National Forests\": \"https://geohub.oregon.gov/api/download/v1/items/b479e4bd7d70439a87e0230c99bddce5/geojson?layers=0\",\n    }\n\n    # Create widgets\n    toggle = ToggleButton(\n        value=True,\n        tooltip=\"Add built-in shapefile\",\n        icon=\"square-o\",\n        layout=Layout(width=\"38px\", height=\"38px\"),\n    )\n\n    dropdown = Dropdown(\n        options=list(SHAPEFILE_LOOKUP.keys()),\n        value=\"None\",\n        placeholder=\"Select a shapefile\",\n        description=\"Select shapefile:\",\n        style={\"description_width\": \"initial\"},\n        layout=Layout(width=\"250px\", height=\"38px\"),\n    )\n\n    # Store reference to current basemap layer\n    if not hasattr(self, \"current_basemap\"):\n        self.current_basemap = self.layers[0]\n\n    def on_dropdown_change(change):\n        \"\"\"Handle shapefile selection changes\"\"\"\n        if change[\"new\"]:\n            geojson_path = SHAPEFILE_LOOKUP[change[\"new\"]]\n            if geojson_path is not None:\n                self.add_geojson(geojson_path, name=change[\"new\"])\n            else:\n                # Remove existing shapefile layer if \"None\" is selected\n                if (\n                    hasattr(self, \"current_geojson_layer\")\n                    and self.current_geojson_layer is not None\n                ):\n                    try:\n                        self.remove_layer(self.current_geojson_layer)\n                    except Exception:\n                        pass\n\n    # Set up event handlers\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    # Assemble and add control\n    widget_box = HBox([toggle])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if change[\"new\"]:\n            widget_box.children = (toggle,)\n        else:\n            widget_box.children = (toggle, dropdown)\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    control = WidgetControl(widget=widget_box, position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.geojson_button","title":"<code>geojson_button(self, **kwargs)</code>","text":"<p>Creates a button to add shapefiles.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def geojson_button(self, **kwargs):\n    \"\"\"Creates a button to add shapefiles.\"\"\"\n    from ipywidgets import Button, Text, ToggleButton, HBox, Layout\n    from ipyleaflet import WidgetControl\n\n    # Create widgets\n    toggle_close = ToggleButton(\n        value=True, tooltip=\"Add GeoJSON from link\", icon=\"link\"\n    )\n\n    url = Text(\n        placeholder=\"Type something\",\n        description=\"GeoJSON URL:\",\n        disabled=False,\n        style={\"description_width\": \"initial\"},\n    )\n\n    run_button = Button(\n        description=\"Add GeoJSON\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        size=38,\n        icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    toggle_close.layout = Layout(width=\"36px\", height=\"36px\")\n\n    # Assemble and add control\n    widget_box = HBox([toggle_close])\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if change[\"new\"]:\n            widget_box.children = (toggle_close,)\n        else:\n            widget_box.children = (toggle_close, url, run_button)\n\n    def on_button_clicked(change):\n        \"\"\"Handles the url upload.\"\"\"\n        if url.value:\n            # For the first file (if multiple=False)\n            geojson_path = url.value\n            self.add_geojson(geojson_path, name=url.value)\n\n    toggle_close.observe(on_toggle_change, names=\"value\")\n\n    run_button.on_click(on_button_clicked)\n\n    control = WidgetControl(widget=widget_box, position=\"topright\")\n\n    self.add_control(control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.handle_click","title":"<code>handle_click(self, **kwargs)</code>","text":"<p>Handles click events on the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def handle_click(self, **kwargs):\n    \"\"\"Handles click events on the map.\"\"\"\n    if kwargs.get(\"type\") == \"click\":\n        self.add_layer(ipyleaflet.Marker(location=kwargs.get(\"coordinates\")))\n\n        print(f\"Clicked at: {kwargs.get('coordinates')}\")\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.upload_geojson_file","title":"<code>upload_geojson_file(self, **kwargs)</code>","text":"<p>Uploads GeoJSON file to the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def upload_geojson_file(self, **kwargs):\n    \"\"\"Uploads GeoJSON file to the map.\"\"\"\n\n    from ipywidgets import FileUpload, Button, ToggleButton, HBox\n\n    button = Button(\n        description=\"Add GeoJSON file\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        size=38,\n        icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    file_upload = FileUpload(\n        accept=\".geojson\",\n        multiple=False,\n        size=38,\n        description=\"Upload GeoJSON\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    close_button = ToggleButton(icon=\"file\", value=True, tooltip=\"Add GeoJSON file\")\n    close_button.layout = widgets.Layout(width=\"36px\", height=\"36px\")\n\n    hbox = HBox([close_button])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if change[\"new\"]:\n            hbox.children = (close_button,)\n        else:\n            hbox.children = (close_button, file_upload, button)\n\n    def on_button_clicked(change):\n        \"\"\"Handles the url upload.\"\"\"\n        if file_upload.value and len(file_upload.value) &gt; 0:\n            import json\n            from ipyleaflet import GeoJSON\n\n            file_info = file_upload.value[0]\n            # Get bytes from memoryview\n            content_bytes = file_info[\"content\"].tobytes()\n            # Decode bytes to string, then load as JSON\n            geojson_data = json.loads(content_bytes.decode(\"utf-8\"))\n            # Add the GeoJSON layer to the map\n            geo_json = GeoJSON(data=geojson_data)\n            self.add_layer(geo_json)\n\n    close_button.observe(on_toggle_change, names=\"value\")\n\n    button.on_click(on_button_clicked)\n\n    upload_control = ipyleaflet.WidgetControl(widget=hbox, position=\"topright\")\n    self.add_control(upload_control)\n</code></pre>"},{"location":"interactive/#skiba.interactive.Map.upload_points","title":"<code>upload_points(self, **kwargs)</code>","text":"<p>Uploads points to the map.</p> Source code in <code>skiba/interactive.py</code> <pre><code>def upload_points(self, **kwargs):\n    \"\"\"Uploads points to the map.\"\"\"\n\n    from ipywidgets import FileUpload, Button, ToggleButton, HBox\n\n    button = Button(\n        description=\"Add Points\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me\",\n        size=38,\n        icon=\"plus\",  # (FontAwesome names without the `fa-` prefix)\n    )\n\n    file_upload = FileUpload(\n        accept=\".csv\",\n        multiple=False,\n        size=38,\n        description=\"Upload CSV\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    close_button = ToggleButton(\n        icon=\"map-pin\", value=True, tooltip=\"Upload points from CSV file\"\n    )\n    close_button.layout = widgets.Layout(width=\"36px\", height=\"36px\")\n\n    hbox = HBox([close_button])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if is_open[0] and change[\"new\"]:\n            hbox.children = (close_button,)\n        else:\n            hbox.children = (close_button, file_upload, button)\n\n    def on_button_clicked(change):\n        \"\"\"Handles the file upload.\"\"\"\n        import io\n\n        if file_upload.value:\n            # For the first file (if multiple=False)\n            file_info = file_upload.value[0]\n            content_bytes = file_info[\"content\"].tobytes()\n            points = pd.read_csv(io.BytesIO(content_bytes))\n            self.add_points(points)\n\n    close_button.observe(on_toggle_change, names=\"value\")\n\n    button.on_click(on_button_clicked)\n\n    upload_control = ipyleaflet.WidgetControl(widget=hbox, position=\"topright\")\n    self.add_control(upload_control)\n</code></pre>"},{"location":"ipyleafletcode/","title":"ipyleaflet code","text":"<p>Main module.</p>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def handle_click(self, **kwargs):\n        import ipywidgets as widgets\n\n        if kwargs.get(\"type\") == \"click\":\n            self.add_layer(widgets.Marker(location=kwargs.get(\"coordinates\")))\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_raster(self, filepath, **kwargs):\n        \"\"\"Add GeoTIFF raster to the map.\n\n        Args:\n            filepath (_type_): _description_\n        \"\"\"\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        client = TileClient(filepath)\n        tile_layer = get_leaflet_tile_layer(client, **kwargs)\n\n        self.add(tile_layer)\n        self.center = client.center()\n        self.zoom = client.default_zoom\n\n    def add_image(self, image, bounds=None, **kwargs):\n        \"\"\"Adds an image to the map.\n\n        Args:\n            image (str): The file path to the image.\n            bounds (list, optional): The bounds for the image. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    def add_video(self, video, bounds=None, **kwargs):\n        \"\"\"Adds a video to the map.\n\n        Args:\n            video (str): The file path to the video.\n            bounds (list, optional): The bounds for the video. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    def add_wms_layer(\n        self, url, layers, format=\"image/png\", transparent=True, **kwargs\n    ):\n        \"\"\"Adds a WMS layer to the map.\n\n        Args:\n            url (str): The WMS service URL.\n            layers (str): The layers to display.\n            **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n        \"\"\"\n        layer = ipyleaflet.WMSLayer(\n            url=url, layers=layers, format=format, transparent=transparent, **kwargs\n        )\n\n        self.add(layer)\n\n    def change_basemap(self, **kwargs):\n        \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n        from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n        from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n        # Map dropdown names to actual basemap objects\n        BASEMAP_LOOKUP = {\n            \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n            \"OpenTopoMap\": basemaps.OpenTopoMap,\n            \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n            \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n        }\n\n        # Create widgets\n        toggle = ToggleButton(\n            value=True,\n            tooltip=\"Toggle basemap selector\",\n            icon=\"map\",\n            layout=Layout(width=\"38px\", height=\"38px\"),\n        )\n\n        dropdown = Dropdown(\n            options=list(BASEMAP_LOOKUP.keys()),\n            value=\"OpenStreetMap\",\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n            layout=Layout(width=\"250px\", height=\"38px\"),\n        )\n\n        # Store reference to current basemap layer\n        if not hasattr(self, \"current_basemap\"):\n            self.current_basemap = self.layers[0]\n\n        def on_dropdown_change(change):\n            \"\"\"Handle basemap selection changes\"\"\"\n            if change[\"new\"]:\n                new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n                self.substitute_layer(self.current_basemap, new_basemap)\n                self.current_basemap = new_basemap\n\n        # def on_toggle_change(change):\n        #     \"\"\"Toggle visibility of dropdown\"\"\"\n        #     if change[\"new\"]:\n        #         dropdown.layout.visibility = 'visible'  # Show dropdown\n        #     else:\n        #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n        # Set up event handlers\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        # Assemble and add control\n        widget_box = HBox([toggle, dropdown])\n\n        is_open = [True]\n\n        def on_toggle_change(change):\n            \"\"\"Toggle visibility of dropdown\"\"\"\n            if is_open[0] and change[\"new\"]:\n                widget_box.children = (toggle, dropdown)\n            else:\n                widget_box.children = (toggle,)\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        control = WidgetControl(widget=widget_box, position=\"topright\")\n        self.add_control(control)\n\n    def add_search_marker(self, **kwargs):\n        \"\"\"Adds a search marker to the map.\"\"\"\n\n        from ipyleaflet import Map, SearchControl, Marker, AwesomeIcon\n\n        search_marker = Marker(\n            icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\")\n        )\n\n        search_control = SearchControl(\n            position=\"topleft\",\n            url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\",\n            zoom=10,\n            marker=search_marker,\n        )\n\n        self.add(search_control)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_image","title":"<code>add_image(self, image, bounds=None, **kwargs)</code>","text":"<p>Adds an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The file path to the image.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the image. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.ImageOverlay layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_image(self, image, bounds=None, **kwargs):\n    \"\"\"Adds an image to the map.\n\n    Args:\n        image (str): The file path to the image.\n        bounds (list, optional): The bounds for the image. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_raster","title":"<code>add_raster(self, filepath, **kwargs)</code>","text":"<p>Add GeoTIFF raster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>_type_</code> <p>description</p> required Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_raster(self, filepath, **kwargs):\n    \"\"\"Add GeoTIFF raster to the map.\n\n    Args:\n        filepath (_type_): _description_\n    \"\"\"\n    from localtileserver import TileClient, get_leaflet_tile_layer\n\n    client = TileClient(filepath)\n    tile_layer = get_leaflet_tile_layer(client, **kwargs)\n\n    self.add(tile_layer)\n    self.center = client.center()\n    self.zoom = client.default_zoom\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_search_marker","title":"<code>add_search_marker(self, **kwargs)</code>","text":"<p>Adds a search marker to the map.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_search_marker(self, **kwargs):\n    \"\"\"Adds a search marker to the map.\"\"\"\n\n    from ipyleaflet import Map, SearchControl, Marker, AwesomeIcon\n\n    search_marker = Marker(\n        icon=AwesomeIcon(name=\"search\", marker_color=\"blue\", icon_color=\"white\")\n    )\n\n    search_control = SearchControl(\n        position=\"topleft\",\n        url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\",\n        zoom=10,\n        marker=search_marker,\n    )\n\n    self.add(search_control)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_video","title":"<code>add_video(self, video, bounds=None, **kwargs)</code>","text":"<p>Adds a video to the map.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>str</code> <p>The file path to the video.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the video. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.VideoOverlay layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_video(self, video, bounds=None, **kwargs):\n    \"\"\"Adds a video to the map.\n\n    Args:\n        video (str): The file path to the video.\n        bounds (list, optional): The bounds for the video. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.VideoOverlay(url=video, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, format='image/png', transparent=True, **kwargs)</code>","text":"<p>Adds a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The WMS service URL.</p> required <code>layers</code> <code>str</code> <p>The layers to display.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.WMSLayer layer.</p> <code>{}</code> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def add_wms_layer(\n    self, url, layers, format=\"image/png\", transparent=True, **kwargs\n):\n    \"\"\"Adds a WMS layer to the map.\n\n    Args:\n        url (str): The WMS service URL.\n        layers (str): The layers to display.\n        **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n    \"\"\"\n    layer = ipyleaflet.WMSLayer(\n        url=url, layers=layers, format=format, transparent=transparent, **kwargs\n    )\n\n    self.add(layer)\n</code></pre>"},{"location":"ipyleafletcode/#skiba.ipyleafletcode.Map.change_basemap","title":"<code>change_basemap(self, **kwargs)</code>","text":"<p>Changes the basemap of the map using a dropdown selector.</p> Source code in <code>skiba/ipyleafletcode.py</code> <pre><code>def change_basemap(self, **kwargs):\n    \"\"\"Changes the basemap of the map using a dropdown selector.\"\"\"\n    from ipywidgets import Dropdown, ToggleButton, HBox, Layout\n    from ipyleaflet import WidgetControl, basemap_to_tiles, basemaps\n\n    # Map dropdown names to actual basemap objects\n    BASEMAP_LOOKUP = {\n        \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n        \"OpenTopoMap\": basemaps.OpenTopoMap,\n        \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n        \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n    }\n\n    # Create widgets\n    toggle = ToggleButton(\n        value=True,\n        tooltip=\"Toggle basemap selector\",\n        icon=\"map\",\n        layout=Layout(width=\"38px\", height=\"38px\"),\n    )\n\n    dropdown = Dropdown(\n        options=list(BASEMAP_LOOKUP.keys()),\n        value=\"OpenStreetMap\",\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n        layout=Layout(width=\"250px\", height=\"38px\"),\n    )\n\n    # Store reference to current basemap layer\n    if not hasattr(self, \"current_basemap\"):\n        self.current_basemap = self.layers[0]\n\n    def on_dropdown_change(change):\n        \"\"\"Handle basemap selection changes\"\"\"\n        if change[\"new\"]:\n            new_basemap = basemap_to_tiles(BASEMAP_LOOKUP[change[\"new\"]])\n            self.substitute_layer(self.current_basemap, new_basemap)\n            self.current_basemap = new_basemap\n\n    # def on_toggle_change(change):\n    #     \"\"\"Toggle visibility of dropdown\"\"\"\n    #     if change[\"new\"]:\n    #         dropdown.layout.visibility = 'visible'  # Show dropdown\n    #     else:\n    #         dropdown.layout.visibility = 'hidden'   # Hide dropdown\n\n    # Set up event handlers\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    # Assemble and add control\n    widget_box = HBox([toggle, dropdown])\n\n    is_open = [True]\n\n    def on_toggle_change(change):\n        \"\"\"Toggle visibility of dropdown\"\"\"\n        if is_open[0] and change[\"new\"]:\n            widget_box.children = (toggle, dropdown)\n        else:\n            widget_box.children = (toggle,)\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    control = WidgetControl(widget=widget_box, position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"point_extraction/","title":"point_extraction module","text":""},{"location":"point_extraction/#skiba.point_extraction.PointExtraction","title":"<code> PointExtraction        </code>","text":"Source code in <code>skiba/point_extraction.py</code> <pre><code>class PointExtraction:\n    def __init__(self):\n        # File Upload\n        self.file_upload = widgets.FileUpload(\n            accept=\".csv, .txt\",  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'\n            multiple=False,  # True to accept multiple files upload else False\n        )\n        # Dropdown\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = PointExtraction.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        self.dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n        self.start_date = widgets.DatePicker(description=\"Start Date\", disabled=False)\n        self.end_date = widgets.DatePicker(description=\"End Date\", disabled=False)\n        self.run_button = widgets.Button(\n            description=\"Run Query\",\n            disabled=False,\n            button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n            tooltip=\"Click me\",\n            icon=\"rotate right\",  # (FontAwesome names without the `fa-` prefix)\n        )\n        self.output = widgets.Output()\n        self.run_button.on_click(self.on_button_clicked)\n        self.dropdown.observe(self.on_dropdown_change, names=\"value\")\n        self.hbox = widgets.HBox(\n            [\n                self.file_upload,\n                self.dropdown,\n                self.start_date,\n                self.end_date,\n                self.run_button,\n            ]\n        )\n        self.vbox = widgets.VBox([self.hbox, self.output])\n\n    def on_dropdown_change(self, change):\n        if change[\"new\"]:\n            with self.output:\n                self.output.clear_output()\n                catalog = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n                data = PointExtraction.fetch_geojson(catalog)\n                data_dict = {item[\"id\"]: item[\"url\"] for item in data if \"id\" in item}\n                change_value = str(change[\"new\"])\n                url = data_dict.get(change_value)\n                print(f\"Selected dataset: {change['new']}\")\n                print(f\"URL: {url}\")\n\n    def on_button_clicked(self, b):\n        with self.output:\n            self.output.clear_output()\n            print(\n                f\"You entered: {self.dropdown.value}. CSV file will be saved to Downloads folder under this name.\"\n            )\n            import io\n\n            if self.file_upload.value:\n                # For the first file (if multiple=False)\n                file_info = self.file_upload.value[0]\n                content_bytes = file_info[\"content\"].tobytes()  # file content as bytes\n                points = pd.read_csv(io.BytesIO(content_bytes))\n                lat_cols = [\"lat\", \"latitude\", \"y\", \"LAT\", \"Latitude\", \"Lat\", \"Y\"]\n                lon_cols = [\n                    \"lon\",\n                    \"long\",\n                    \"longitude\",\n                    \"x\",\n                    \"LON\",\n                    \"Longitude\",\n                    \"Long\",\n                    \"X\",\n                ]\n                id_cols = [\"id\", \"ID\", \"plot_ID\", \"plot_id\", \"plotID\", \"plotId\"]\n\n                def find_column(possible_names, columns):\n                    for name in possible_names:\n                        if name in columns:\n                            return name\n                    # fallback: check case-insensitive match\n                    lower_columns = {c.lower(): c for c in columns}\n                    for name in possible_names:\n                        if name.lower() in lower_columns:\n                            return lower_columns[name.lower()]\n                    raise ValueError(f\"No matching column found for {possible_names}\")\n\n                lat_col = find_column(lat_cols, points.columns)\n                lon_col = find_column(lon_cols, points.columns)\n                id_col = find_column(id_cols, points.columns)\n                points = points.rename(\n                    columns={lat_col: \"LAT\", lon_col: \"LON\", id_col: \"plot_ID\"}\n                )\n            else:\n                print(\"Please upload a CSV file.\")\n            geedata = self.dropdown.value\n            start_date = self.start_date.value\n            end_date = self.end_date.value\n            self.get_coordinate_data(\n                data=points, geedata=geedata, start_date=start_date, end_date=end_date\n            )\n\n    def get_coordinate_data(self, data, geedata, start_date, end_date, **kwargs):\n        \"\"\"\n        Pull data from provided coordinates from GEE.\n\n        Args:\n            data (str): The data to get the coordinate data from.\n\n        Returns:\n            data (str): CSV file contained GEE data.\n        \"\"\"\n\n        # Load data with safety checks\n        if isinstance(data, str):\n            coordinates = pd.read_csv(data)\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        elif isinstance(data, pd.DataFrame):\n            coordinates = data\n            gdf = gpd.GeoDataFrame(\n                coordinates,\n                geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n                crs=\"EPSG:4326\",  # Directly set CRS during creation\n            )\n        else:\n            gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n        geojson = gdf.__geo_interface__\n        fc = gm.geojson_to_ee(geojson)\n        # Load the GEE dataset as an image\n        geeimage = PointExtraction.load_gee_as_image(geedata, start_date, end_date)\n        name = f\"{geedata}\"\n        file_name = name.replace(\"/\", \"_\")\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        output_file = f\"{file_name}.csv\"\n        out_path = os.path.join(out_dir, output_file)\n        # Retrieve data from the image using sampleRegions\n        sampled_data = gm.extract_values_to_points(fc, geeimage, out_path)\n        return sampled_data\n\n    def fetch_geojson(url):\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raises an exception for HTTP errors\n            geojson_data = response.json()  # Parse the JSON response\n            return geojson_data\n        except requests.exceptions.HTTPError as http_err:\n            print(f\"HTTP error occurred: {http_err}\")\n        except requests.exceptions.ConnectionError as conn_err:\n            print(f\"Error connecting to the server: {conn_err}\")\n        except Exception as err:\n            print(f\"An error occurred: {err}\")\n        return None\n\n    def create_dropdown():\n        \"\"\"\n        Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n        Args:\n            url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n        Returns:\n            ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n        \"\"\"\n\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        data = PointExtraction.fetch_geojson(url)\n        data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n        dropdown = widgets.Dropdown(\n            options=data_dict,  # keys shown, values returned\n            description=\"Dataset:\",\n            disabled=False,\n        )\n        return dropdown\n\n    def add_date_picker():\n        date_picker = widgets.DatePicker(description=\"Pick a Date\", disabled=False)\n        return date_picker\n\n    def load_gee_as_image(dataset_id, start_date, end_date, **kwargs):\n        \"\"\"\n        Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n        Optionally filters by start and end date if applicable.\n\n        Parameters:\n            dataset_id (str): The Earth Engine dataset ID.\n            start_date (str): Optional start date in 'YYYY-MM-DD' format.\n            end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n        Returns:\n            ee.Image: The resulting image.\n        \"\"\"\n        url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n        response = requests.get(url)\n        response.raise_for_status()  # Raises an exception for HTTP errors\n        geojson_data = response.json()\n        data_type = [item[\"type\"] for item in geojson_data if item[\"id\"] == dataset_id]\n        data_str = \" \".join(data_type)\n        start_date = str(start_date)\n        end_date = str(end_date)\n        # Try loading as Image\n        if data_str == \"image\":\n            img = ee.Image(dataset_id)\n            # If .getInfo() doesn't throw, it's an Image\n            img.getInfo()\n            return img\n        elif data_str == \"image_collection\":\n            col = ee.ImageCollection(dataset_id)\n            # If date filters are provided, apply them\n            if start_date is None and end_date is None:\n                col = col.filterDate(start_date, end_date)\n            else:\n                pass\n            # Reduce to a single image (e.g., median composite)\n            img = col.median()\n            return img\n        # Try loading as FeatureCollection (convert to raster)\n        else:\n            # fc_temp = ee.FeatureCollection(dataset_id)\n            # if start_date is None and end_date is None:\n            #         fc_temp = fc_temp.filterDate(start_date, end_date)\n            # # Convert to raster: burn a value of 1 into a new image\n            # img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.median())\n            # img.getInfo()\n            # return img\n            # or print(f\"Dataset must be either an Image or Image Collection\")\n            raise ValueError(\"Dataset ID is not a valid Image or ImageCollection.\")\n</code></pre>"},{"location":"point_extraction/#skiba.point_extraction.PointExtraction.create_dropdown","title":"<code>create_dropdown()</code>","text":"<p>Creates an ipywidgets dropdown menu from a GeoJSON catalog.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the GeoJSON catalog. Defaults to the Opengeos catalog.</p> required <p>Returns:</p> Type Description <code>ipywidgets.Dropdown</code> <p>A dropdown widget with the names from the catalog.</p> Source code in <code>skiba/point_extraction.py</code> <pre><code>def create_dropdown():\n    \"\"\"\n    Creates an ipywidgets dropdown menu from a GeoJSON catalog.\n\n    Args:\n        url (str, optional): URL to the GeoJSON catalog. Defaults to the Opengeos catalog.\n\n    Returns:\n        ipywidgets.Dropdown: A dropdown widget with the names from the catalog.\n    \"\"\"\n\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    data = PointExtraction.fetch_geojson(url)\n    data_dict = {item[\"title\"]: item[\"id\"] for item in data if \"title\" in item}\n    dropdown = widgets.Dropdown(\n        options=data_dict,  # keys shown, values returned\n        description=\"Dataset:\",\n        disabled=False,\n    )\n    return dropdown\n</code></pre>"},{"location":"point_extraction/#skiba.point_extraction.PointExtraction.get_coordinate_data","title":"<code>get_coordinate_data(self, data, geedata, start_date, end_date, **kwargs)</code>","text":"<p>Pull data from provided coordinates from GEE.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to get the coordinate data from.</p> required <p>Returns:</p> Type Description <code>data (str)</code> <p>CSV file contained GEE data.</p> Source code in <code>skiba/point_extraction.py</code> <pre><code>def get_coordinate_data(self, data, geedata, start_date, end_date, **kwargs):\n    \"\"\"\n    Pull data from provided coordinates from GEE.\n\n    Args:\n        data (str): The data to get the coordinate data from.\n\n    Returns:\n        data (str): CSV file contained GEE data.\n    \"\"\"\n\n    # Load data with safety checks\n    if isinstance(data, str):\n        coordinates = pd.read_csv(data)\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    elif isinstance(data, pd.DataFrame):\n        coordinates = data\n        gdf = gpd.GeoDataFrame(\n            coordinates,\n            geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n            crs=\"EPSG:4326\",  # Directly set CRS during creation\n        )\n    else:\n        gdf = data.to_crs(epsg=4326)  # Ensure WGS84\n    geojson = gdf.__geo_interface__\n    fc = gm.geojson_to_ee(geojson)\n    # Load the GEE dataset as an image\n    geeimage = PointExtraction.load_gee_as_image(geedata, start_date, end_date)\n    name = f\"{geedata}\"\n    file_name = name.replace(\"/\", \"_\")\n    out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n    output_file = f\"{file_name}.csv\"\n    out_path = os.path.join(out_dir, output_file)\n    # Retrieve data from the image using sampleRegions\n    sampled_data = gm.extract_values_to_points(fc, geeimage, out_path)\n    return sampled_data\n</code></pre>"},{"location":"point_extraction/#skiba.point_extraction.PointExtraction.load_gee_as_image","title":"<code>load_gee_as_image(dataset_id, start_date, end_date, **kwargs)</code>","text":"<p>Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image. Optionally filters by start and end date if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The Earth Engine dataset ID.</p> required <code>start_date</code> <code>str</code> <p>Optional start date in 'YYYY-MM-DD' format.</p> required <code>end_date</code> <code>str</code> <p>Optional end date in 'YYYY-MM-DD' format.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The resulting image.</p> Source code in <code>skiba/point_extraction.py</code> <pre><code>def load_gee_as_image(dataset_id, start_date, end_date, **kwargs):\n    \"\"\"\n    Loads any GEE dataset (Image, ImageCollection, FeatureCollection) as an ee.Image.\n    Optionally filters by start and end date if applicable.\n\n    Parameters:\n        dataset_id (str): The Earth Engine dataset ID.\n        start_date (str): Optional start date in 'YYYY-MM-DD' format.\n        end_date (str): Optional end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        ee.Image: The resulting image.\n    \"\"\"\n    url = \"https://raw.githubusercontent.com/opengeos/geospatial-data-catalogs/master/gee_catalog.json\"\n    response = requests.get(url)\n    response.raise_for_status()  # Raises an exception for HTTP errors\n    geojson_data = response.json()\n    data_type = [item[\"type\"] for item in geojson_data if item[\"id\"] == dataset_id]\n    data_str = \" \".join(data_type)\n    start_date = str(start_date)\n    end_date = str(end_date)\n    # Try loading as Image\n    if data_str == \"image\":\n        img = ee.Image(dataset_id)\n        # If .getInfo() doesn't throw, it's an Image\n        img.getInfo()\n        return img\n    elif data_str == \"image_collection\":\n        col = ee.ImageCollection(dataset_id)\n        # If date filters are provided, apply them\n        if start_date is None and end_date is None:\n            col = col.filterDate(start_date, end_date)\n        else:\n            pass\n        # Reduce to a single image (e.g., median composite)\n        img = col.median()\n        return img\n    # Try loading as FeatureCollection (convert to raster)\n    else:\n        # fc_temp = ee.FeatureCollection(dataset_id)\n        # if start_date is None and end_date is None:\n        #         fc_temp = fc_temp.filterDate(start_date, end_date)\n        # # Convert to raster: burn a value of 1 into a new image\n        # img = fc_temp.reduceToImage(properties=[], reducer=ee.Reducer.median())\n        # img.getInfo()\n        # return img\n        # or print(f\"Dataset must be either an Image or Image Collection\")\n        raise ValueError(\"Dataset ID is not a valid Image or ImageCollection.\")\n</code></pre>"},{"location":"skiba/","title":"skiba module","text":"<p>Main module.</p>"},{"location":"usage/","title":"Usage","text":"<p>To use skiba in a project:</p> <pre><code>import skiba.buffer_coordinates as sbc\nimport skiba.buffer_and_sample as sbs\nimport skiba.point_extraction as spe\n</code></pre>"},{"location":"examples/folium_demo/","title":"Folium demo","text":"<p>\"\"</p> In\u00a0[\u00a0]: Copied! <pre>import skiba.foliumcode as skiba\n</pre> import skiba.foliumcode as skiba In\u00a0[\u00a0]: Copied! <pre>m = skiba.Map(center=[37.5, -95], zoom=4)\nurl = \"https://data-usfs.hub.arcgis.com/api/download/v1/items/4a48c9a7ad3144f7890ff85d5dd76f1e/geojson?layers=2\"\nm.add_geojson(url)\nm.add_split_map(left=\"Esri.WorldImagery\", right=\"openstreetmap\")\nm.add_layer_control()\nm\n</pre> m = skiba.Map(center=[37.5, -95], zoom=4) url = \"https://data-usfs.hub.arcgis.com/api/download/v1/items/4a48c9a7ad3144f7890ff85d5dd76f1e/geojson?layers=2\" m.add_geojson(url) m.add_split_map(left=\"Esri.WorldImagery\", right=\"openstreetmap\") m.add_layer_control() m In\u00a0[\u00a0]: Copied! <pre>m2 = skiba.Map(center=[32.765745, 22.643689], zoom=4)\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nurl2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\nm2.add_split_map(url, url2)\nm2\n</pre> m2 = skiba.Map(center=[32.765745, 22.643689], zoom=4) url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\" m2.add_split_map(url, url2) m2"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[\u00a0]: Copied! <pre>print(\"Hello World!\")\n\nprint(\"Goodbye World!\")\n</pre> print(\"Hello World!\")  print(\"Goodbye World!\")"},{"location":"examples/ipyleaflet_demo/","title":"Ipyleaflet demo","text":"<p>\"\"</p> In\u00a0[\u00a0]: Copied! <pre>import skiba.ipyleafletcode as skibaipy\n\nskibaipy.Map\n</pre> import skiba.ipyleafletcode as skibaipy  skibaipy.Map In\u00a0[\u00a0]: Copied! <pre>m = skibaipy.Map(center=[37.5, -95], zoom=4)\nurl = \"https://github.com/opengeos/datasets/releases/download/vector/hike.geojson\"\nm.add_geojson(url)\n# m.add_basemap(\"Esri.WorldImagery\")\nm.add_layer_control()\nm\n</pre> m = skibaipy.Map(center=[37.5, -95], zoom=4) url = \"https://github.com/opengeos/datasets/releases/download/vector/hike.geojson\" m.add_geojson(url) # m.add_basemap(\"Esri.WorldImagery\") m.add_layer_control() m In\u00a0[\u00a0]: Copied! <pre>m.change_basemap()\n</pre> m.change_basemap()"},{"location":"examples/map_demo/","title":"Map demo","text":"In\u00a0[\u00a0]: Copied! <pre>import skiba.ipyleafletcode as sm\n</pre> import skiba.ipyleafletcode as sm In\u00a0[\u00a0]: Copied! <pre>sm.Map\n</pre> sm.Map In\u00a0[\u00a0]: Copied! <pre>m = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)\nurl = \"https://data.fs.usda.gov/geodata/rastergateway/downloadMap.php?mapID=354508215&amp;mapType=tif\"\n# m.add_raster(\"HMA_DM_6H_v01_DEMe_1km.tif\")\nm.add_raster(url)\nm\n</pre> m = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True) url = \"https://data.fs.usda.gov/geodata/rastergateway/downloadMap.php?mapID=354508215&amp;mapType=tif\" # m.add_raster(\"HMA_DM_6H_v01_DEMe_1km.tif\") m.add_raster(url) m In\u00a0[\u00a0]: Copied! <pre>m2 = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)\nurl2 = \"https://media.giphy.com/media/NvNyuTD794sIIPntaw/giphy.gif\"\nm2.add_image(url2, bounds=[[25, 50], [40, 20]], opacity=0.5)\nm2\n</pre> m2 = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True) url2 = \"https://media.giphy.com/media/NvNyuTD794sIIPntaw/giphy.gif\" m2.add_image(url2, bounds=[[25, 50], [40, 20]], opacity=0.5) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)\nurl3 = \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\"\nm3.add_video(url3, bounds=[[13, -130], [32, -100]], opacity=1)\nm3\n</pre> m3 = sm.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True) url3 = \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\" m3.add_video(url3, bounds=[[13, -130], [32, -100]], opacity=1) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = sm.Map(center=(38.491, -95.712), zoom=4, scroll_wheel_zoom=True)\nurl4 = \"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\"\nm4.add_wms_layer(url4, layers=\"nexrad-n0r-900913\")\nm4\n</pre> m4 = sm.Map(center=(38.491, -95.712), zoom=4, scroll_wheel_zoom=True) url4 = \"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\" m4.add_wms_layer(url4, layers=\"nexrad-n0r-900913\") m4 In\u00a0[\u00a0]: Copied! <pre>m4 = sm.Map(center=(38.491, -95.712), zoom=4, scroll_wheel_zoom=True)\nurl4 = \"https://imagery.nationalmap.gov/arcgis/services/USGSNAIPPlus/ImageServer/WMSServer?\"\nm4.add_wms_layer(url4, layers=\"USGSNAIPPlus\", format=\"image/png\", transparent=True)\nm4\n</pre> m4 = sm.Map(center=(38.491, -95.712), zoom=4, scroll_wheel_zoom=True) url4 = \"https://imagery.nationalmap.gov/arcgis/services/USGSNAIPPlus/ImageServer/WMSServer?\" m4.add_wms_layer(url4, layers=\"USGSNAIPPlus\", format=\"image/png\", transparent=True) m4"},{"location":"examples/point_extraction_demo/","title":"Point extraction demo","text":"<p>\"\"</p> In\u00a0[\u00a0]: Copied! <pre># !pip install skiba # uncomment if need to install the package\nimport skiba.point_extraction as spe\nimport ee\n\nee.Authenticate()\nee.Initialize(project=\"ee-forestplotvariables\")\n</pre> # !pip install skiba # uncomment if need to install the package import skiba.point_extraction as spe import ee  ee.Authenticate() ee.Initialize(project=\"ee-forestplotvariables\") In\u00a0[\u00a0]: Copied! <pre>m = spe.point_extraction().vbox\nm\n</pre> m = spe.point_extraction().vbox m In\u00a0[\u00a0]: Copied! <pre>import ipywidgets as widgets\n</pre> import ipywidgets as widgets In\u00a0[\u00a0]: Copied! <pre>start_date = widgets.DatePicker(description=\"Start Date\", disabled=False)\nstart_date\n</pre> start_date = widgets.DatePicker(description=\"Start Date\", disabled=False) start_date In\u00a0[\u00a0]: Copied! <pre>date = str(start_date.value)\nprint(date)\nprint(start_date.value)\n</pre> date = str(start_date.value) print(date) print(start_date.value) In\u00a0[\u00a0]: Copied! <pre>import geemap as gm\nimport skiba.geojson_buffering as gb\n</pre> import geemap as gm import skiba.geojson_buffering as gb In\u00a0[\u00a0]: Copied! <pre>m = gb.buffer_coordinates().vbox\nm\n</pre> m = gb.buffer_coordinates().vbox m In\u00a0[\u00a0]: Copied! <pre>import skiba.interactive as interactive\n</pre> import skiba.interactive as interactive In\u00a0[\u00a0]: Copied! <pre>meep = interactive.Map()\nmeep\n</pre> meep = interactive.Map() meep In\u00a0[\u00a0]: Copied! <pre>path = \"../data/selected_coordinates.csv\"\n\nimport geopandas as gpd\nimport pandas as pd\nimport ipyleaflet\n\ncoordinates = pd.read_csv(path)\ngdf = gpd.GeoDataFrame(\n    coordinates,\n    geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),\n    crs=\"EPSG:4326\",  # Directly set CRS during creation\n)\n\npoint_style = {\n    \"radius\": 2,\n    \"color\": \"black\",\n    \"dashArray\": \"2\",\n    \"fillOpacity\": 1,\n    \"fillColor\": \"red\",\n    \"weight\": 1,\n}  # 'color': 'white',\n\ngeo_data = ipyleaflet.GeoData(\n    geo_dataframe=gdf,\n    point_style=point_style,\n)\n\nmeep.add(geo_data)\n</pre> path = \"../data/selected_coordinates.csv\"  import geopandas as gpd import pandas as pd import ipyleaflet  coordinates = pd.read_csv(path) gdf = gpd.GeoDataFrame(     coordinates,     geometry=gpd.points_from_xy(coordinates.LON, coordinates.LAT),     crs=\"EPSG:4326\",  # Directly set CRS during creation )  point_style = {     \"radius\": 2,     \"color\": \"black\",     \"dashArray\": \"2\",     \"fillOpacity\": 1,     \"fillColor\": \"red\",     \"weight\": 1, }  # 'color': 'white',  geo_data = ipyleaflet.GeoData(     geo_dataframe=gdf,     point_style=point_style, )  meep.add(geo_data) In\u00a0[\u00a0]: Copied! <pre>path = \"../data/parks_forests_southern_app.geojson\"\nmeep.add_geojson(path)\n</pre> path = \"../data/parks_forests_southern_app.geojson\" meep.add_geojson(path) In\u00a0[\u00a0]: Copied! <pre>from ipyleaflet import Map, GeoData, basemaps, LayersControl\nimport ipywidgets as widgets\n\ngdf = gpd.read_file(\"../data/shapefiles/nc_nf.shp\")\ncenter = [gdf.geometry.centroid.y.mean(), gdf.geometry.centroid.x.mean()]\ngeo_data = GeoData(\n    geo_dataframe=gdf,\n    name=\"My Layer\",\n    style={\"color\": \"black\", \"fillColor\": \"black\", \"fillOpacity\": 0.6},\n)\nmeeper = Map(\n    center=center,\n    zoom=7,\n    scroll_wheel_zoom=True,\n    basemap=basemaps.Esri.NatGeoWorldMap,\n    layout=widgets.Layout(height=\"600px\"),\n)\nmeeper.add_control(LayersControl())\nmeeper.add_layer(geo_data)\n\ngdf = gpd.read_file(\"../data/shapefiles/national_forests.shp\")\ngeo_data = GeoData(\n    geo_dataframe=gdf,\n    name=\"My Layer\",\n    style={\"color\": \"black\", \"fillColor\": \"black\", \"fillOpacity\": 0.6},\n)\nmeeper.add_layer(geo_data)\n\ngdf = gpd.read_file(\"../data/shapefiles/np_nf_combined.shp\")\n# gdf = gdf.drop(columns=['EditDate', 'DATE_EDIT', 'CreationDa'])\ngeo_data = GeoData(\n    geo_dataframe=gdf,\n    name=\"My Layer\",\n    style={\"color\": \"black\", \"fillColor\": \"black\", \"fillOpacity\": 0.6},\n)\nmeeper.add_layer(geo_data)\n\nmeeper\n</pre> from ipyleaflet import Map, GeoData, basemaps, LayersControl import ipywidgets as widgets  gdf = gpd.read_file(\"../data/shapefiles/nc_nf.shp\") center = [gdf.geometry.centroid.y.mean(), gdf.geometry.centroid.x.mean()] geo_data = GeoData(     geo_dataframe=gdf,     name=\"My Layer\",     style={\"color\": \"black\", \"fillColor\": \"black\", \"fillOpacity\": 0.6}, ) meeper = Map(     center=center,     zoom=7,     scroll_wheel_zoom=True,     basemap=basemaps.Esri.NatGeoWorldMap,     layout=widgets.Layout(height=\"600px\"), ) meeper.add_control(LayersControl()) meeper.add_layer(geo_data)  gdf = gpd.read_file(\"../data/shapefiles/national_forests.shp\") geo_data = GeoData(     geo_dataframe=gdf,     name=\"My Layer\",     style={\"color\": \"black\", \"fillColor\": \"black\", \"fillOpacity\": 0.6}, ) meeper.add_layer(geo_data)  gdf = gpd.read_file(\"../data/shapefiles/np_nf_combined.shp\") # gdf = gdf.drop(columns=['EditDate', 'DATE_EDIT', 'CreationDa']) geo_data = GeoData(     geo_dataframe=gdf,     name=\"My Layer\",     style={\"color\": \"black\", \"fillColor\": \"black\", \"fillOpacity\": 0.6}, ) meeper.add_layer(geo_data)  meeper In\u00a0[\u00a0]: Copied! <pre>gdf = gpd.read_file(\"../data/shapefiles/np_nf_combined.shp\")\ngdf.head()\n</pre> gdf = gpd.read_file(\"../data/shapefiles/np_nf_combined.shp\") gdf.head() In\u00a0[\u00a0]: Copied! <pre>gdf = gpd.read_file(\"../data/shapefiles/national_forests.shp\")\ngdf.head()\n</pre> gdf = gpd.read_file(\"../data/shapefiles/national_forests.shp\") gdf.head()"},{"location":"examples/point_extraction_demo/#import-package","title":"Import package\u00b6","text":""},{"location":"examples/point_extraction_demo/#run-widget","title":"Run widget\u00b6","text":""},{"location":"examples/usage/","title":"Usage","text":"<p>\"\"</p> <p>For local development, install the package in editable mode:</p> In\u00a0[\u00a0]: Copied! <pre># pip install -e .\n</pre> # pip install -e . <p>Some packages imported for from local development process and examples below:</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap as gm\nimport pandas as pd\nimport geopandas as gpd\nfrom shapely.geometry import Point\nimport os\n</pre> import ee import geemap as gm import pandas as pd import geopandas as gpd from shapely.geometry import Point import os <p>Authenticate with Google Drive to access data for point extractions only:</p> In\u00a0[\u00a0]: Copied! <pre># Initialize Earth Engine\nee.Authenticate()\nee.Initialize(project=\"ee-forestplotvariables\")\n</pre> # Initialize Earth Engine ee.Authenticate() ee.Initialize(project=\"ee-forestplotvariables\") <p>Single-point extraction tool:</p> In\u00a0[\u00a0]: Copied! <pre>import skiba.point_extraction as point_extraction\n\npost = point_extraction.PointExtraction().vbox\npost\n</pre> import skiba.point_extraction as point_extraction  post = point_extraction.PointExtraction().vbox post <p>Aggregated-point extraction tool:</p> In\u00a0[\u00a0]: Copied! <pre>import skiba.aggregated_point_extraction as sape\n\npoint = sape.AggregatedPointExtraction().vbox\npoint\n</pre> import skiba.aggregated_point_extraction as sape  point = sape.AggregatedPointExtraction().vbox point <p>Buffer coordinate to single point</p> In\u00a0[\u00a0]: Copied! <pre>import skiba.buffer_coordinates as bc\n\nbc = bc.BufferCoordinates().vbox\nbc\n</pre> import skiba.buffer_coordinates as bc  bc = bc.BufferCoordinates().vbox bc <p>Buffer coordinate to multiple points (n)</p> In\u00a0[\u00a0]: Copied! <pre>import skiba.buffer_and_sample as sbs\n\nmultiple = sbs.Buffer().vbox\nmultiple\n</pre> import skiba.buffer_and_sample as sbs  multiple = sbs.Buffer().vbox multiple In\u00a0[\u00a0]: Copied! <pre>import skiba.interactive as interactive\n\nmap = interactive.Map()\npath = \"../data/1000.0ft.csv\"\nmap.add_points(path)\npath1 = \"../data/selected_coordinates.csv\"\nmap.add_points(path1)\nmap\n</pre> import skiba.interactive as interactive  map = interactive.Map() path = \"../data/1000.0ft.csv\" map.add_points(path) path1 = \"../data/selected_coordinates.csv\" map.add_points(path1) map In\u00a0[\u00a0]: Copied! <pre>m = gm.Map()\npath = \"../data/10.0.geojson\"\nm.add_geojson(path)\npath1 = \"../data/selected_coordinates.csv\"\nm\n</pre> m = gm.Map() path = \"../data/10.0.geojson\" m.add_geojson(path) path1 = \"../data/selected_coordinates.csv\" m"},{"location":"examples/usage/#developers-notes-to-developers","title":"Developer's Notes to Developers\u00b6","text":""},{"location":"examples/usage/#gee","title":"GEE\u00b6","text":"<p>Extractions</p>"},{"location":"examples/usage/#buffering-approaches","title":"Buffering Approaches\u00b6","text":""},{"location":"examples/usage/#mapping-demo-with-skiba-and-geemap","title":"Mapping demo with skiba and geemap\u00b6","text":""},{"location":"paper/paper/","title":"Paper","text":"<p>authors:     - name: Tara Skiba         orcid: 0009-0002-5354-3319         equal-contrib: true         affiliation: 1     - name: Qiusheng Wu         orcid: 0000-0001-5437-4073         equal-contrib: false         affiliation: 2     - name: Tyler Gifford         orcid: 0000-0002-2547-3547         equal-contrib: false         affiliation: 1</p> <p>affiliations:     - name: University of Tennessee, School of Natural Resources, USA         index: 1     - name: University of Tennessee, Department of Geography, USA         index: 2</p> <p>date: 18 April 2025 bibliography: paper.bib</p>"},{"location":"paper/paper/#summary","title":"Summary","text":"<p><code>skiba</code> is a python package deployed on hugging face to allow natural resource professionals such as foresters or wildlife managers to access and retrieve data from Google Earth Engine. This purpose of this package is designed to extract values for a list of provided coordinate points with .</p>"},{"location":"paper/paper/#introduction","title":"Introduction","text":"<p>In recent decades, remote sensing has become an invaluable tool in a multitude of fields, due to the versatility of data collected and potential applications<code>[@chiBigDataRemote2016]</code>. Such information can be revolutionary in the field of forestry, particularly for inventory and research purposes where large-scale or intense monitoring is difficult or impossible to conduct. However, the uptake of remote sensing in forestry has been slow due to a multitude of reasons, as outlined in <code>[fassnachtRemoteSensingForestry2024a]</code>. In addition, several major issues need to be overcome before remote sensing can be fully integrated into standard forestry practices, such as determining forest type, identifying individual trees and species, particularly in mixed-species, uneven aged stands <code>[@burkhartForestMeasurements2019; @jeronimoApplyingLiDARIndividual2018a]</code>.</p> <p>Despite this, foresters and forest biometricians can still utilize publicly available remotely sensed data for information that is not standard in a traditional forest inventory, and forest biometricians can consider various untested environmental and climatological variables to help explain forest dynamics, such as predicting live aboveground carbon (pending publication). Remotely sensed data can still be difficult to access due to various technical barriers as hosting platforms, like Google Earth Engine (GEE), require a proficiency in programming and handling geospatial data retrieve the desired information.</p> <p>Various tools and packages currently exist to help users streamline this point-oriented acquisition process, such as GEE\u2019s built-in Code Editor. However, these tools still require programming skills and a free, easy-to-use, point-and-click interface that does not require any programming knowledge does not yet exist. Other geographical software programs can query this information, such as ArcGIS and QGIS, but these programs may require a license, and the user must still have a proficient understanding of geospatial analysis to use the software. Even within open source projects for python, querying GEE data can still be a multi-step process that requires various package installations and coding in order to handle the data. A simplified process does not yet exist to help streamline this data acquisition.</p> <p>This package was developed to complement the USDA Forest Service's Forest Inventory and Analysis's (FIA) long-term national inventory as a part of a project using climate and environmental data from GEE databases. The FIA's inventory has been used frequently by forest biometricians due to the large spatial scale and long temporal scale of this database that can help answer large-scale questions. Due to how time intensive traditional forest inventories are, one plot is taken for every 6,000 acres (<code>@bechtoldEnhancedForestInventory2015</code>). Due to the sampling intensity and structure of this inventory design, plots are treated as individual observations in studies. In some instances, smaller grouping levels, such as condition level groups as described in <code>@yangEstimatingMaximumStand2022</code> and <code>@jhaEvaluationRegressionMethods2023</code>, are treated as individual observations, but smaller grouping levels within the plot may be assumed to have shared characteristics. Examples are elevation, slope, or aspect, which, if measured, are only taken at plot center and not the subplot or any other sub-plot level grouping. Furthermore, only the plot center's coordinates are recorded in the FIA database. Therefore, to complement the FIA's national inventory and its standard use in forest modeling, this package was designed to operate from this plot-level perspective by extracting the values from a GEE dataset for a specified coordinate point (plot center). This approach is appropriate to query data for any grouping level equal to or smaller than the plot level.</p> <p>This project will be expanded to fit the needs of forest biometricians as they are presented, such as extracting the mean value for a given area and increasing the map's functionality. More geojson layers will be added as well, such as national forests and parks. Furthermore, as this project is hosted on GitHub, users who are comfortable with python can expand and contribute to this package's functionality for their purposes. While this package was developed with forest biometricians in mind, this package can be beneficial to other natural resource professionals who may also desire to utilize the vast range of data available as desired.</p>"},{"location":"paper/paper/#skiba-audience","title":"skiba Audience","text":"<p><code>skiba</code> is intended for natural resource professionals who would like to extract Google Earth Engine data for given coordinates, but the use of this package can be useful in other disciplines. This package removes the technological barriers that limit the package\u2019s intended users from being able to utilize remotely sensed data. Users can access the base version of this package through huggingface (\u2026TBD), and users can modify and build upon this package through the package\u2019s GitHub and PyPI repositories. By design, this package is fairly rudimentary, with the goal of expanding the functions of this package to meet the needs of natural resource professionals accordingly. Two additional functions are currently being developed: a polygon buffering tool that will allow users to preserve any confidential coordinates they have and function that will extract temporal data, such as daily or monthly averages, for temporal analyses.</p> <p>This package has been used in existing research projects to query data and will be presented at various local and national conferences to promote its use to a broader range of users, as well as to the USFS Southern Research Station's FIA group in Knoxville, TN as an alternative to outsourcing their remote sensing needs to another office.</p>"},{"location":"paper/paper/#skiba-functionality","title":"skiba Functionality","text":"<p>The <code>skiba</code> package is built upon <code>@ipyleaflet</code> and <code>@geemap</code>, while also utilizing <code>@pandas</code> and <code>@geopandas</code> for data handling and <code>@ee</code> for source data. <code>skiba</code> is broken into two key modules: -   <code>map_details</code>: module for displaying an interactive map with uploaded coordinates plotted. Users may customize the map as allowed. This module uses <code>@ipyleaflet</code>, <code>@ipywidgets</code>, and <code>@geemap</code>. A walkthrough of this map feature can be found in <code>map_details_demo.ipynb</code> -   <code>data_process</code>: module for processing GEE data and returning the desired information for the user-provided coordinates. This module utilizes <code>@geemap</code>, <code>@pandas</code>, <code>@geopandas</code>, and <code>@ipywidgets</code>. A full demonstration of this module can be found in <code>data_process_demo.ipynb</code>.</p>"},{"location":"paper/paper/#skiba-user-guide","title":"skiba User Guide","text":"<ul> <li>Step 1:   The User uploads a csv or xlsx file that must at least the following three columns: a plot identifier (e.g. plot #), latitude (in dd.), longitude (in dd.).</li> <li>Example csv file format:     <pre><code>\"plot_ID\",\"LAT\",\"LON\"\n\"37_39_63\",35.138399,-84.180002\n</code></pre> Note: latitude and longitude column names must match example format</li> <li>Step 2:   A map will appear with provided coordinates plotted.      Example of <code>map_details</code> module with sample dataset.</li> <li>Step 3:   User selects a Google Earth Engine dataset from the dropdown.</li> <li>Step 3.b (Optional):   User selects desired time frame.</li> <li>Step 4:   Package returns a csv file with point values from all bands of provided coordinates within selected GEE dataset. The csv file will be automatically saved in the user's local <code>~/Downloads</code> folder.</li> <li>Note: the full website is still pending, but temporary demos can be found as stated in the functionality section. This package may be temporarily used through the package's Colab pages until the official website is built.</li> </ul>"},{"location":"paper/paper/#acknowledgements","title":"Acknowledgements","text":"<p>The author would like to thank the developers of geemap, ipyleafet, and ipywidgets, which were heavily utilized to efficiently create a map and query the desired data. The author would also like to thank the the USDA's U.S. Forest Service Forest Inventory and Analysis program for their financial support.</p>"},{"location":"paper/paper/#references","title":"References","text":""}]}